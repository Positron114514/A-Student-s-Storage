#算法 

> 对于回文字符串对称性的充分利用

# 寻找字符串中最长的回文字符串

考虑如下问题:

已知字符串, 需要你从中找出最长的回文字符串, 应该如何解决?

首先想到的方法, 也是最为直观的方法, 就是遍历整个字符串. 对每个字符, 检测如下两种回文字符串:

- 长度为奇数的回文字符串: 以该字符为中心, 逐个检测左右两边的字符是否相等, 直至不相等或达到字符串边界
- 长度为偶数的回文字符串: 从该字符和该字符右侧第一个字符开始检测, 直至不相等或达到边界

将得到的长度和最长的长度进行比较, 得出结果.

代码如下:

```cpp
int get_max_len(std::string& s) {
    int len = s.size();
    int max_len = 0;

    for (int i = 0; i < len * 2; i++) {
        int l = i / 2 - i % 2; // 根据i的奇偶决定检测奇数还是偶数长度的回文串
        int r = l + 2 - i % 2;

        while (l >= 0 && r < len) {
            if (s[l] != s[r]) {
                break;
            }
            l--;
            r++;
        }
        // cout << "i = " << i << ", len = " << r - l - 1 << endl; 
        if (max_len < r - l - 1) {
            max_len = r - l - 1;
        }
    }

    return max_len;
}
```

可以求得该算法的时间复杂度为 $O(n^2)$ 

# 改进算法

有没有更好的方法了呢?

考虑如下情况:

![[../../Excalidraw/mlc|mlc]]

我们还是从左到右遍历该字符串

当遍历到第三个元素时, 我们得知其回文串长度为5, 此时继续遍历, 当 i 继续增大至5时, 我们能够根据回文串的对称性得知: 下一个位置的回文串长度与其镜像位置, 即位置3的回文串长度相同, 都为0. 

i 为6时, 根据对称性得到回文串长度为3. 注意此时当长度为3时, 回文串的边界与回文串中心所处的大回文串的边界重合, 因此无法判断回文串长度是否大于3. 我们将其初始值设为3, 存入下方的P数组中, 从3开始, 按照刚才算法逐个检测其左右元素是否相等, 最终得到该回文字符串的长度.

如何实现该算法呢? 我们创建变量 `max_r` 和 `max_p`, 分别记录当前最靠右的回文串边界和其中心所处位置, 代码如下:

```cpp
int get_max_len_better(string& s) {
    int length = s.size();
    int max_len = 0;
    vector<int> p(length * 2 - 1, 0);
    int max_p = -1, max_r = -1;

    for (int i = 0; i < length * 2; i++) {
        int l = i / 2 - i % 2;
        int r = l + 2 - i % 2;
        if (i <= max_r) {
            int mir = max_p * 2 - i;
            if (mir >= 0) {
                l -= p[mir] / 2 - i % 2;
                r += p[mir] / 2 - i % 2;
            }
        }

        while (l >= 0 && r < length && s[l] = s[r]) {
            l--;
            r++;
        }

        p[i] = r - l - 1;
        // cout << "i = " << i << ", len = " << r - l - 1 << endl;
        if (max_len < r - l - 1) {
            max_len = r - l - 1;
        }
        if (max_r < r - 1) {
            max_r = r - 1;
            max_p = i;
        }
    }

    return max_len;
}
```

可以看到, 当充分利用了回文串的对称性后, 计算量大大减少, 时间复杂度也从原来的 $O(n^2)$ 降至 $O(n)$ 