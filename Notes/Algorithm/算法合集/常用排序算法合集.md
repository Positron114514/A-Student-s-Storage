
# 冒泡排序

> 最基础 (简单) 的排序算法

## 原理

冒泡排序通过不断地交换数组中相邻的元素, 将较大 (或较小) 的元素逐渐 "浮" 到数组的顶端 (或底端) , 在每一轮遍历中，相邻的两个元素进行比较，如果它们的顺序不正确，则交换它们。这样，经过一轮遍历，最大（或最小）的元素就会被"浮"到数组的末尾，然后在下一轮遍历中，继续这个过程，直到所有元素都排好序为止。

以目标为递增为例:

1. 从数组的第一个元素开始, 依次比较相邻的两个元素. 
2. 如果前一个元素大于后一个元素 , 则交换两元素的位置. 
3. 继续这个过程, 直到遍历到仍未排序的数组的末尾. 
4. 重复以上步骤, 每次遍历都将未排序部分的最大 (或最小) 元素 "浮" 到数组的末尾. 
5. 经过若干轮遍历之后, 数组就会变得有序. 

冒泡排序的时间复杂度为 O(n^2), 其中 n 是数组的大小, 可见其性能相对较差. 在大规模数据排序时不推荐使用.

## 算法实现

```cpp
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻两个元素
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```


# 插入排序

## 原理

插入排序 (Insertion Sort) 是一种简单直观的排序算法. 每次从未排序部分取出一个元素, 插入到已排序部分的合适位置, 直到所有元素都被排序. 

具体步骤如下: 

1. 从第一个元素开始, 该元素可以认为已经被排序. 
2. 取出下一个元素, 在已经排序的数组部分中从后向前扫描。
3. 如果已排序的元素大于新元素, 则将该元素后移一位. 
4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置。
5. 将新元素插入到该位置后。
6. 重复步骤2~5，直到所有元素都被插入到正确的位置。

插入排序的时间复杂度为O(n^2)，其中 n 是数组的大小。它对于较小规模的数据或基本有序的数据集效果较好，但在大规模数据集上效率较低。

## 算法实现

```cpp
void insertionSort(vector<int> &arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        // 将 arr[0..i-1] 中大于 key 的元素向右移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            --j;
        }

        arr[j + 1] = key;
    }
}
```


# 快速排序

## 原理

快速排序 (Quick Sort) 是一种采用了分治思想来实现的排序算法. 该算法的基本思想选择一个基准元素, 将数组分成两部分, 一部分是小于基准元素的元素, 另一部分是大于基准元素的元素, 然后对这两部分分别再进行递归排序, 最终实现整个数组的排序, 

具体步骤如下:

1. 选择一个基准元素 (通常是数组的最后一个元素). 
2. 将数组分成两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于基准元素。
3. 对左右两部分分别进行递归排序. 
4. 合并左右两部分, 得到排序后的数组. 

快速排序的平均时间复杂度为 O(nlogn), 其中 n 是数组的大小. 在最坏情况下, 时间复杂度为 O(n^2), 但是在实际应用中, 快速排序通常是效率最高的排序算法之一.

## 算法实现

```cpp
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为pivot元素
    int i = low - 1;  // i指向小于等于pivot的元素的最后一个位置

	// 保证左侧元素均小于pivot, 右侧元素均大于pivot
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// 快速排序函数
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);  // pi为分区点
        quickSort(arr, low, pi - 1);   // 对左半部分进行快速排序
        quickSort(arr, pi + 1, high);  // 对右半部分进行快速排序
    }
}
```