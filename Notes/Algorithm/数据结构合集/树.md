#数据结构 

# 一. 树的基本概念

## 1. 树的定义

树是n（n>=0）个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：

1. 有且仅有一个特定的称为根的结点。
2. 当n>1时，其余节点可分为m（m>0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。

树本身是递归的

**树的特点:**

1. 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
2. 树中所有结点可以有零个或多个后继。


## 2. 基本术语

![[../../Excalidraw/Tree|Tree]]

1. 考虑结点K。根A到结点K的唯一路径上的任意结点,称为结点K的**祖先**。如结点B是结点K的祖先,而结点K是结点B的**子孙**。路径上最接近结点K的结点E称为K的**双亲**,而K为结点E的**孩子**。根A是树中唯一没有双亲的结点。有相同双亲的结点称为**兄弟**,如结点K和结点L有相同的双亲E,即K和L为兄弟。
2. 树中一个结点的孩子个数称为该**结点的度**,树中结点的最大度数称为**树的度**。如结点B的度为3,结点D的度为2, 树的度为3。
3. 度大于0的结点称为**分支结点**(又称**非终端结点**);度为0(没有子女结点)的结点称为**叶子结点**(又称**终端结点**)。在分支结点中,每个结点的分支数就是该结点的度。
4. 结点的深度、高度和层次。  
    **结点的层次**从树根开始定义,根结点为第1层,它的子结点为第2层,以此类推。双亲在同一层的结点互为**堂兄弟**,图中结点G与E,F,H,I,J互为堂兄弟。  
    **结点的深度**是从根结点开始自顶向下逐层累加的。  
    **结点的高度**是从叶结点开始自底向上逐层累加的。  
    **树的高度**(或**深度**)是树中结点的最大层数。图中树的高度为4。
5. 有序树和无序树。树中结点的各子树从左到右是有次序的,不能互换,称该树为**有序树**,否则称为**无序树**。假设图为有序树,若将子结点位置互换,则变成一棵不同的树。
6. 路径和路径长度。树中两个结点之间的**路径**是由这两个结点之间所经过的结点序列构成的,而**路径长度**是路径上所经过的边的个数。  
    注意:由于树中的分支是有向的,即从双亲指向孩子,所以树中的路径是从上向下的,同一双亲的两个孩子之间不存在路径。
7. 森林。**森林**是m (m≥0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。


## 3. 树的基本性质

1. 树中的结点数等于所有结点的度数加1.
2. 度为m mm的树中第i ii层上至多有m i − 1 m^{i-1}mi−1个结点（i > = 1 i>=1i>=1）
3. 高度为h hh的m mm叉树至多有( m h − 1 ) / ( m − 1 ) (m^h-1)/(m-1)(mh−1)/(m−1)个结点。
4. 具有n nn个结点的m mm叉树的最小高度为[ l o g m ( n ( m − 1 ) + 1 ) ] [log_m(n(m-1)+1)][logm​(n(m−1)+1)]。


# 二. 树的存储结构

以这棵树为例:

![[../../Excalidraw/Tree_b|Tree_b]]

## 1. 双亲表示法

即每个节点都知道他的双亲是什么

```c
// 树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 1000
typedef int TreeElemType;  // 树结点的数据类型，目前暂定为整型
// 结点结构
typedef struct PTreeNode {
    TreeElemType data;  // 结点数据
    int parent;      // 双亲位置
} PTreeNode;
// 树结构
typedef struct {
    PTreeNode nodes[MAX_TREE_SIZE];  // 结点数组
    int r, n;                     // 根的位置和结点数
} PTree;
```

这种存储方法便于找到树的根

当`parent`值为 -1 时说明找到了根

## 2. 孩子表示法

具体办法是，**把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中**，如图所示。

![[../../00 Resource/res/tree_child.png]]

即: 

- data数组只存储数据和指向孩子单元的指针, 孩子单元存储孩子所在的位置指针(数组下标)和指向下一个孩子单元的指针

```cpp
/*树的孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
/*孩子结点*/
typedef struct CTNode{
	int child;
	struct CTNode *next;
}*ChildPtr;
/*表头结点*/
typedef struct{
	TElemType data;
	ChildPtr firstchild;
}CTBox;
/*树结构*/
typedef struct{
	CTBox nodes[MAX_TREE_SIZE];	//结点数组
	int r, n;	//根的位置和结点数
}

```

也可以有两者结合的表示方法

> [!Todo] 如何将孩子表示法和兄弟表示法结合


## 3. 孩子兄弟表示法

设置两个指针, 第一个指向第一个孩子, 第二个指向右侧的兄弟

```cpp
/*树的孩子兄弟表示法结构定义*/
typedef struct CSNode{
	TElemtype data;
	struct CSNode *firstchild, *rightsib;
} CSNode, *CSTree;

```

如图:

![[../../00 Resource/res/tree_brother_child.png]]

**将复杂的树变成了二叉树**


# 三. 二叉树

## 3.1 概念

### 3.1.1 定义

每个结只有最多两个孩子(即二叉树的度小于等于2), 且其子树有左右之分, 不能随意颠倒

与树相似，二叉树也以递归的形式定义。二叉树是n (n≥0) 个结点的有限集合:

1. 或者为空二叉树，即n=0。
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

二叉树的五种形态: 

![[../../00 Resource/res/5_types_of_2_tree.png]]

### 3.1.2 几个特殊的二叉树

**斜树**

所有点都在一侧

**满二叉树**

节点的度均为2(除了叶节点)

**完全二叉树**

高度为h hh、有n nn个结点的二叉树，当且仅当其每个结点都与高度为h hh的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树，如图所示。其特点如下:  

![[../../00 Resource/res/total_2_tree.png]]

1. 若i ≤ n / 2 i≤n/2i≤n/2, 则结点i ii为分支结点，否则为叶子结点。
2. 叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。
3. 若有度为1 11的结点，则只可能有一个，且该结点只有左孩子而无右孩子(重要特征)。
4. 按层序编号后，一旦出现某结点(编号为i ii)为叶子结点或只有左孩子，则编号大于i ii的结点均为叶子结点。
5. 若n nn为奇数，则每个分支结点都有左孩子和右孩子;若n nn为偶数，则编号最大的分支结点(编号为n / 2 n/2n/2)只有左孩子，没有右孩子，其余分支结点左、右孩子都有。

**二叉排序树**

左子树上所有结点的关键字均小于根结点的关键字;右子树上的所有结点的关键字均大于根结点的关键字;左子树和右子树又各是一棵二叉排序树。

**平衡二叉树**

树上任一结点的左子树和右子树的深度之差不超过1。

### 3.1.3 二叉树的性质

