#软件工程与计算 #程序设计 #python 

> 课件: [[../钮老师课件/06 - 2编程实践-递归.pdf|06 - 2编程实践-递归]]

递归用来解决具有自我重复结构的问题

# 1. 结构

- 一个 / 多个**基本情形**
- 一个 / 多个约简问题的方法
- 一个 / 多个使用更小问题的解来解决更大问题


# 2. 迭代和递归

> SICP: [[../SICP/1. 构造过程和抽象#1.2.1 线性的递归和迭代|线性的递归和迭代]]

迭代: 更多的底层细节

递归: 更高的抽象

**迭代 $\to$ 递归**: 迭代的状态可以作为参数传递

**递归 $\to$ 迭代**: 找出什么状态需要被追踪

1. 尽量转化为尾递归 (即最后一句执行语句为一个递归调用) 
	1. 如何转化: 将中间状态作为参数传递
	2. 某些语言会优化尾递归 (如 JS Scheme)
2. 将尾递归转化为迭代:
	1. 初始化 accumulator 的值
	2. 使用递归中的基本条件的逆命题作为迭代终止条件
	3. 将递归的函数体转化为迭代的主题
	4. 循环结束后用基本case的值更新 accumulator 的值并返回

Example: 

```python
# acccumulator 记录了中间状态
def tail_fact(n, accumulator = 1):
	if n == 1:
		return accumulator
	return tail_fact(n - 1, accumulator * n)

def iter_fact(n):
	ret = 1
	while n > 1:
		ret *= n
		n -= 1
	return ret

a = tail_fact(10)
```

另一种通用的转化方法: 用代码模拟栈的操作 (原神)

丘奇不动点: 

```python
F = lambda f: lambda n: 1 if n == 0 else n * f(n - 1)  
  
y = lambda f: (lambda x: f(x(x)))(lambda x: f(x(x)))  
  
fact = y(F)  
  
print(fact(10))
```

会爆栈 (由于 python 过早求值函数)

换一个组合子: Z combinator

```python
F = lambda f: lambda n: 1 if n == 0 else n * f(n - 1)  
  
Z = (lambda f: (lambda x: f(lambda v: x(x)(v)))(lambda x: f(lambda v: x(x)(v))))  
  
fact = Z(F)  
  
print(fact(10))
```

可以正常运行

# 3. 验证递归的实现

> 数学归纳法 ()

1. 验证基本情形
2. 数学归纳

# 4. 互递归

若两个函数 A B, A 调用了 B, B 调用了 A, 则称 A B 是互递归的

Example:

```python
def is_even(n):
	if n == 0:
		return True
	return is_odd(n - 1)

def is_odd(n):
	if n == 0:
		return False
	return is_even(n - 1)

result = is_even(4)
```

**互递归 $\to$ 直接递归**

通过将一个函数的代码内联进另一个函数中从而变成单个的递归函数

内联: 类似于直接替换

Example:

```python
def is_even(n):
	if n == 0:
		return True
	else:
		if (n - 1) == 0:
			return False
		return is_even((n - 1) - 1)
```

# 5. 树形递归

一个递归在函数体中多次调用自身

Exmaple:

```python
# 把一个数分割, 且分割数不大于一个 m 值
def get_split(n, current_spl):  
    if n == 0:  
        return 1  
    if current_spl <= 0 or n < 0:
	    return 0
    return get_split(n - current_spl, current_spl) + get_split(n, current_spl - 1)
```

