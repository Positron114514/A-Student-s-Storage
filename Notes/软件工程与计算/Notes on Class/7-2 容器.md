#软件工程与计算 #程序设计 #python 

> 课件: [[../钮老师课件/07 - 2 编程实践-容器.pdf|07 - 2 编程实践-容器]]

[[../../Programming/python/python学习笔记#六. 常用数据结构|python笔记]]

# 1. 列表

每个列表中的元素对应两个指标

![[../../00 Resource/res/Pasted image 20240408093529.png]]

**包含关系**: in

```python
>>> list1 = [1, 2, 3, 4]
>>> 1 in list1
True
>>> 8 in list1
False
```

**迭代**:

```python
# 名字 '_' 绑定在当前环境中, 而非一个新的帧(C)
for _ in list1:
	...
```

可迭代的: 可以用 `iter` 获得其迭代器

```python
a = iter(list1)
print(next(a))
```

**序列解包**:

```python
a, b, c, d = list1
print(a)
# output: 1
```

变量数量必须和列表中元素数量相等

```python
list2 = [1]
a = list2 # a = [1]
b, = list2 # b = 1

list3 = [1, 2, 3, 4, 5, 6]
a, *b, c = list3 # b = [2, 3, 4, 5]

list4 = [[1, 2], [1, 3], [3, 4]]
for x, y in list4:
	print(x + y)
```

## 1.1 范围

```python
range(<start>, <end>, <step>)
```

## 1.2 缺省参数

即 [[../../Programming/python/python学习笔记#四. 函数|默认参数]]

```python
def pressure(v, t, n=6.022e23):
	... 
```

## 1.3 序列切片

获取序列的部分子序列, 会得到一个新的序列

直接赋值会得到指向同一个列表的两个名字


## 1.4 列表推导式

```python
a = [x for x in list1 if x % 2 == 0]
```

```python
def division(n):
	return [1] + [i for i in range(2, n) if n % i is 0]
```

## 1.5 序列操作

**sum**

返回和

```python
sum([1, 2, 3, 4, 5])
sum([1, 2, 3], 4)
sum([[1], [2, 3]], [])
sum(1, 2) # wrong
sum([1, 2, 3], [1]) # wrong
```

**max**

返回最大值

```python
max([1, 2, 3]) # 3
max(range(10), key = lambda x: (x - 2) * (x - 4)) # 9
```

**min**

返回最小值, 用法和 `max` 相同

**any**

若均为假则返回假, 否则返回真

```python
any([x > 10 for x in range(1, 12)]) # True
```

**all**

若均为真则返回真, 否则返回假

```python
all([x > 10 for x in range(5)]) # False
```

使用 `help(<function_name>)` 来获取某个函数的文档信息

# 2. 字符串

```python
'shit'

"shitty"

"""
hello, you play 
Genshin impact!
"""
```

python可以将字符串转化为可执行的程序

```python
f = 'curry = lambda f: lambda x: lambda y: f(x, y)'
exec(f)
# now curry is in the current frame
```

in 可以用于查找是否为某个字串的子串

```python
>>> 'in' in 'Genshin'
True
```

# 3. 字典

![[../../Programming/python/python学习笔记#4. 字典|字典]]

即哈希表

键值对的集合

规则: 

- 一个字典里的所有的键都必须是不同的 
- 一个字典里的键不能是一个列表或者字典, 或者其他可变的类型 
- 值的类型不受限制

用键索引值

```python
d1 = {
	  "GI": "Genshin Impact"
	  "DOS": "Divinity: Origin Sin"
	  "SC": "SuperCell"
}

d1.get("DOS") # "Divinity: Origin Sin"
d1.get("SS") # None
d1["SS"] # wrong
d1.keys()
```

迭代字典: 键按照他们第一次加入的顺序进行迭代

# 4. 树

**类型的闭包属性**

一种构成复合数据的方式具有闭包属性当且仅当 如果其生成的复合数据可以作为元素之一被用同样的方式进一步 复合. 比如，列表可以作为元素被另一个列表所包含。

闭包允许创建层次结构

**树抽象**

[[../../Algorithm/数据结构合集/树|树]] 有一个根节点和一系列分支. 树的每个分支都是树, 没有分支的称为叶子

树中包含的树称为子树

![[../../00 Resource/res/Pasted image 20240415092717.png]]

实现树抽象

```python
def is_tree(tree):
	if type(tree) != list or len(tree) < 1
		return False
	for branch in branches(tree):
		if not is_tree(tree):
			return False
	return True

def branch(tree):
	return tree[1:]

def lable(tree):
	return tree[0]

def tree(lable, branches=[]):
	for branch in branches:
		assert is_tree(branch)
	return [lable] + list(branches)
```

**树为无环图** , 因此如果自指, 上述实现无法判断. 因此还需要判断列表中有没有环

```python
tree1 = [1, [1]]
tree1[1] = tree1
```

**树操作**: 利用递归处理树

```python
def count_leaves(tree):
	if is_leaf(tree)
		return 1
	branch_num = [count_leaves(x) for x in branch(tree)]
	return sum(branch_num)


```

# 5. 链表

算是只有一个节点的树

```python
four = [1, [2, [3, [4, 'empty']]]]
```

结合:

```python
def extend_link(s, t):
	assert is_link(s) and is_link(t)
	if s == empty:
		return t
	return link(first(s), extend_link(rest(s), t))
```

