#软件工程与计算 #程序设计 #OOP #python 

> PPT: [[../钮老师课件/10 - 1 编程进阶-继承.pdf|10 - 1 编程进阶-继承]]

一种关联多种类的技术

# 继承

创建一个类, 为另一个类的子类

新创建的类继承了原类的属性

子类可以添加自己的专有属性, 也可以重写父类的属性 (override)

## 重写

子类可以重新定义在父类中的变量和方法

**使用基类中的方法**:

`super().method()` 会调用父类中的方法, 并将调用 `super()` 所在的方法的第一个参数 (一般为 self ) 作为方法的第一个参数的实参

Example:

```python
class Elephant(Animal):
	def eat(self, food):
		if food.type == 'meat':
			super().eat(food) # same as: Animal.eat(self, food)
```

**重写 `__init__`**:

```python
class Elephant(Animal):
	def __init__(self, name, age=0):
		super().__init__(name, age)
		if age < 1:
			self.calories_need = 1000
		elif age < 5:
			self.calories_need = 3000		
```

## 继承的层次性

把类划分成多个种类, 而后继承

![[../../00 Resource/res/Pasted image 20240429094506.png]]

# 多重继承

python 中可以继承多个基类

![[../../00 Resource/res/Pasted image 20240429094613.png]]

```python
class Animal:
	...

class Prey(Animal):
	...

class Herbivore(Animal):
	...

class Rabbit(Prey, Herbivore):
	...
```

**菱形继承问题**: 

![[../../00 Resource/res/Pasted image 20240429100325.png]]

有向无环图 $\to$ 有拓扑序

Method Resolution Order (MRO): 一般情况下：从左到右，从下到上的拓扑排序 （C3 linearization 算法）

# Is-a relationship

任何子类的对象都是其基类的对象

```python
isinstance() # 检查是否为类的一个实例
issubclass() # 检查是否为一个类的子类
```

**Quiz**

> 老师说这个很适合考试

```python
class Parent: 
	def f(s): 
		print("Parent.f") 
		
	def g(s): 
		s.f() 
		
		
class Child(Parent): 
	def f(me): 
		print("Child.f") 
		
a_child = Child() 
a_child.g()

# Output: Child.f
```

**继承的缺点**:

- 打破了封装性：继承强制对子类开发者知道其父类的内部信息 
- 继承所带来的代价：需要存储超类的变量、构造子、方法、但可 能只有少量的超类方法被用到

# 组合

一个对象可以拥有其他类的对象的引用

**Has-a** relationship

```python
class f:
	def func():
		pass

class g:
	def __init__(self):
		self._f = f()

	def shit():
		self._f.func()
```

缺点: 

- 使用组合时，当我们需要处理某些请求时，我们其 实需要委托（delegation）某个类型的对象的方法 去完成相应的请求。 
- 写法上没有继承的“直接复用”相应方法方便。

# Mixin

- 在python中，Mixin是一个类，其包含一些属性方法，但其本身不是为了实 例化对象 
- 它的存在是为了让其他类可以拥有这些方法（在python中通过继承来得 到，但在其他语言中，不一定要作为父类，如Java接口的默认方法、Scala 的trait、Ruby的module）
- 每一个Mixin类应该提供一些紧密相关的方法，为了实现“一个”特有的行为 
- 代表了“-able” relationship

python新建对象时, 并没有把函数复制进去

因此这样不会造成臃肿

```python
class MappingMixin:
	""" python内置方法, 可以让访问对象数据像访问字典那样实现
	example: 
	a = Rabbit()
	a["age"]
	"""
	def __getitem__(self, key):
		return self.__dict__.get(key)
		
	def __setitem__(self, key, value):
		return self.__dict__.set(key, value)

class Rabbit(MappingMixin, Animal):
	pass
```

最好把 `Mixin` 放在真正的基类之前 (如上)

