#软件工程与计算 #python #程序设计 

> PPT: [[../钮老师课件/08 - 1 编程实践-可变性.pdf|08 - 1 编程实践-可变性]]


# 1. 元组

创建后无法改变其值

以逗号分隔元素表达式的元组文本创建的，圆括号是可选的（但在实践中经常使用）

其中元素可以为任意类型的对象

```python
>>> ()
()
>>> 1,
(1,)
>>> 1, 2
(1, 2)
>>> (1, 2)
(1, 2)
>>> code = (1, 2, 3, 4) + (1, 2) * 2
>>> code
(1, 2, 3,  4, 1, 2, 1, 2)
>>> b = (1, [1, 2, 3])
>>> b[1][0] = 5
>>> b
(1, [5, 2, 3]) # 整数也是不可变的
```

# 2. 可变性

Python中的不可变类型: `int` `bool` `float` `string` `tuple` 

可变: 如 `list` `dict` 

**拷贝**:

- 浅拷贝: 创建一个新的对象, 然后把原对象中的元素的引用拷贝
- 深拷贝: 创建一个新的对象, 然后把原对象中的所有值递归的拷贝到新对象中

```python
a = [1, 2, 3, [1, 2, 3]]
b = a
c = copy.copy(a) # 浅
e = a.copy()     # 浅
d = copy.deepcopy(a) # 深
a.append(5)
a[3].append(4) # c = [1, 2, 3, [1, 2, 3, 4]] , b = [1, 2, 3, [1, 2, 3, 4], 5], d = [1, 2, 3, [1, 2, 3]]
```

可以通过 `slicing` 来改变列表的值, 但将 `slicing` 的值赋给一个新的对象会赋值其拷贝, 因此无法通过新的对象来改变

```python
L = [1, 2, 3, 4]
L[0:0] = [-1, -2, -3] # L = [-1, -2, -3, 1, 2, 3, 4]
```

`remove`: 移除列表中所有该元素

`a.update(b=dict)`: 相当于将b加到a上

# 3. 同一性和相等性

- 同一性: 两个数据指向同一个对象
- 相等性: 两个数据对象蕴含的值相等

Beware: may not act like you expect for strings/numbers! Python interpreter does some optimization for strings/numbers

python会把一些常用值存在一个常量池中, 赋值时直接调用常量池中的东西

# 4. 作用域

```python
attendeees = []

def add_att(name):
	attendees.append(name) # ok

current = 0

def count():
	current = current + 1     # wrong
	print("Count: ", current) # wrong, new local variable 'current'
```

- 本地帧能访问全局帧的值, 但不能重新赋值

```python
current = 0

def count():
	global current
	current = current + 1 # ok
```

尽量避免使用 `global`

父作用域同理:

```python
def make_counter(start):
	current = start

	def count():
		nonlocal current
		current = current + 1
		print("Count: ", current)

	return count
```


一个用法:

```python
def pair(a, b):
	def operate(which, v=None):
		nonlocal a, b
		if which == 0:
			return a
		elif which == 1:
			return b
		elif which = 2:
			a = v
		else:
			b = v
	return operate
```


使用 `list` 避免 `nonlocal`

**作用域规则**:

![[../../00 Resource/res/Pasted image 20240415115007.png]]

**缺省参数**是和函数绑定在一起的

可变的缺省参数是危险的

Example:

```python
def try(s=[]):
	s.append(3)
	return s

try() # [3]
try() # [3, 3]
```


