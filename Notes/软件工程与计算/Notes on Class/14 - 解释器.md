
# 解释

解释器遵循着如下的基本流程： 
- 读取（Read）用户的输入（并转化为表达式） 
- 求值（Evaluate）表达式 
- 打印（Print）结果 
- 循环（Loop）上述过程直至结束 这个流程就是Read-Eval-Print Loop（REPL）


## 定义一个 "计算器" 语言

这个过程也叫 “Metalinguistic Abstraction”，新创造的语言也 被称为“domain-specific languages”

一个新的语言往往有利于更好的描述问题空间

> 挺像 Lisp 的()

```calc
>>> +(3, 4)
7
>>> +(3, *(4, 5), 6)
29
```

### Read

read

### Parsing

一个解析器（Parser）接受字符串的输入并返回一个表达式 , 其含有两个主要步骤：词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）

```python
def calc_parse(line): 
	tokens = tokenize(line) 
	expression_tree = analyze(tokens) 
	return expression_tree
```

### Evaluation

表达式树 -> 值

- 基本表达式直接求值为其所表示的数值 
- 调用表达式递归的求值： 
	- 对每个操作数进行求值（Evaluate） 
	- 将求得的值放到实参的列表上 
	- 将操作符作用在实参列表上（Apply）


```python
def calc_eval(exp):
	if type(exp) in (int, float): 
		return exp 
	elif type(exp) == Exp: 
		arguments = list(map(calc_eval, exp.operands)) 
		return calc_apply(exp.operator, arguments)

def calc_apply(operator, args): 
	if operator in ('add', '+'): 
		return sum(args) 
	if operator in ('sub', '–'): 
		if len(args) == 1: 
			return –args[0] 
		return sum(args[0] + [–arg for arg in args[1:]])
```

## 解释一个 Python 的子集语言 Py

有 **环境** 和 **语句**

### 环境

可以用字典绑定环境

定义一个环境类:

```python
class Environment:
	def __init__(self, father_environment=None):
		self.father = father_environment
		self.bindings = {}
		self.nonlocals = []
	
	def is_global(self):
		return self.father is None
	
	# 标记nonlocal变量
	def note_nonlocal(self, var):
		self.nonlocal.append(var)
	
	# 定义了该方法后，可以通过 对象名[var] 来获得相应的属性值
	def __getitem__(self, var):
		if var in self.bindings:
			return self.bindings[var]
		elif not self.is_global():
			return self.father[var]
		else:
			raise NameNotFoundException()
	
	def set_variable(self, name, value, is_nonlocal=False):
		if is_nonlocal:
			self.enclosing[name] = value
		else:
			self.bindings[name] = value
	
	# 定义了该方法后，可以通过 对象名[name] = value 来设置的属性值
	def __setitem__(self, name, value):
		self.set_variable(name, value, name in self.nonlocals)
```

### 语句

- 赋值语句：自动对表达式进行求值，并将值绑定到目标名字上 
- 调用语句：对操作符和操作数分别求值，然后将执行Apply 
- 控制语句： 复合语句，包含布尔表达式，语句块，首先对布尔表 达式进行求值，根据结果是否对语句块中的语句进行求值

**赋值语句**:

```python
class AssignStmt(Stmt):

	def __init__(self, target, expr):
		self.target = target
		self.expr = expr
	
	def evaluate(self, env):
		env[self.target] = self.expr.evaluate(env)
```

**调用语句**:

```python
class CallExpr(Expr):
	def __init__(self, op_expr, opnd_exprs): 
		self.op_expr = op_expr 
		self.opnd_exprs = opnd_exprs 
		
	def evaluate(self, env): 
		func_value = self.op_expr.evaluate(env) 
		opnd_values = [opnd.evaluate(env) for opnd in self.opnd_exprs] 
		return func_value.apply(opnd_values)
```

**构造函数表达**:

```python
class Function: 
	def __init__(self, *args): 
		raise NotImplementedError() 
		
	def apply(self, operands): 
		raise NotImplementedError() 
		

class PrimitiveFunction(Function): 
	def __init__(self, procedure): 
		self.body = procedure 
	def apply(self, operands): 
		return self.body(operands)
```

**内建基本函数**:

```python
primitive_functions = [ 
			   ("or", PrimitiveFunction(lambda x, y: x or y)), 
			   ("and", PrimitiveFunction(lambda x, y: x and y)), 
			   ("not", PrimitiveFunction(lambda x: not x)), 
			   ("eq", PrimitiveFunction(lambda x, y: x == y)), 
			   ("ne", PrimitiveFunction(lambda x, y: x != y)), ... ] 
			   
def setup_global(): 
	for name, primitive in primitive_functions: 
		the_global_environment[name] = primitive
```

**用户定义函数**

```python
class CompoundFunction(Function): 
	def __init__(self, args, body, env): 
		self.args = args # 参数
		self.body = body # 函数体
		self.env = env   # 所在帧
		
	def apply(self, operands): 
		call_env = Environment(self.env) # 创建一个帧
		if len(self.args) != len(operands): # 参数数量是否相等
			raise TypeError("Wrong number of arguments passed to function!") 
		
		for name, value in zip(self.args, operands): 
			call_env[name] = value # 将实参绑定到形参上
			# 在当前帧中, 对函数体内每个语句进行求值
			for statement in self.body: 
				try: 
					statement.evaluate(call_env) 
				except StopFunction as sf: 
					return sf.return_value 
			return None
```

将返回语句和异常实现的主要原因是：抛出异常之后直接终止正常的运行，进入到异常的处理过程， 这个方式和返回语句语义相似：一旦遇到retrun 语句，则不再顺序执行下面的代码，而是直接返回值

```python
class StopFunction(BaseException):
	def __init__(self, return_value):
		self.return_value = return_value
	
class ReturnStmt(Stmt):
	def __init__(self, expr=None):
		self.expr = expr
	
	def evaluate(self, env):
		if self.expr is None:
			raise StopFunction(None)
		raise StopFunction(self.expr.evaluate(env))
```

**控制语句**:

```python
class ControlStmt(Stmt):
	def __init__(self, expr, blocks):
		self.expr = expr
		self.blocks = blocks
	
	def evaluate(self, env):
		var = self.expr.evaluate(env) 
		executed = [] 
		if var: 
			executed = blocks[0] 
		else: executed = blocks[1] 
		
		for statement in executed: 
			statement.evaluate(env)
```

- 我们实际上是用“python的程序语句”来表达对象语言 （我们自己定义的语言）的语义 
- 这种表达语义的方式就是操作语义（“Operational Semantics”），即描述语言是如何执行的

# 抽象解释

安全性问题: 

安全: 没有坏事发生

不可判定的

![[../../00 Resource/res/Pasted image 20240527104424.png]]


**测试**: 本身是具体语义上的 sample 技术, 不能解决该问题 (有限次) , 会漏掉一些可能会造成非安全状态的输入

**有界模型检验**: 会枚举所有可能的输入状态，但受限于计算资源，只能考虑有限计算时间内的安全性

**抽象解释**: 

赋予语句抽象语义： 利用抽象的域来替代无限的输入，状态的迁移变成了抽象域的迁移，大大减少了计算空间！

Example: 给定一个程序，判定程序中所有数字变量的正负性（正数、 负数、或者0）

- 不可判定!

如何解决: **近似**

## 抽象语义

具体: 数字 -> 抽象

- 抽象域:
	- 正数 `+`
	- 负数 `-`
	- 0      `0`
	- 都可能 `⊤`
	- 非法 `⊥`
- 迁移函数:
	- `+` + `+` = `+`
	- `-` - `+` = `-`
	- `0` + `0` = 0
	- `+` + `-` = `⊤`
	- $\cdots$ 

![[../../00 Resource/res/Pasted image 20240527110801.png]]

%%  %%