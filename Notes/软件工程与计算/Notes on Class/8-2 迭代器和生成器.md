#软件工程与计算 #python #程序设计 

> PPT: [[../钮老师课件/08 - 2 编程实践-迭代器和生成器.pdf|08 - 2 编程实践-迭代器和生成器]]

# 1. 迭代器

**可迭代**: 列表 元组 字典 Ranges 字符串 集合

```python
list1 = [1, 2, 3]
iter_list1 = iter(list1)

x1 = next(iter_list1) # 1
x2 = next(iter_list1) # 2
x3 = next(iter_list1) # 3
x4 = next(iter_list1) # Exception: 迭代终止
```

处理 `StopIteration`

```python
list1 = [1, 2, 3]

iter1 = iter(list1)

try:
	while(True):
		print(next(iter1))
except StopIteration:
	print("no more left")

print("Finished")
```

`iter` 和 `next` 本质上是调用对象自己的 `__iter__` 和 `__next__`

`for` 循环比 `iter` 快一些

## 返回迭代子的函数: 

- `reversed(iterable)`: 返回逆向迭代子
- `zip(*iters)` : 返回一个迭代器, 其元素是一个个元组, 每个元组中的元素是每个 `iters` 中的元素
- `map(func, iterable)`: 返回迭代器, 其中每个元素是 `func(x)`
- `filter(func, iterable)`: 过滤掉 `iterable` 中 `func(x)` 为甲的元素

`iter(iter(x))` = `iter(x)`

因此下面这段代码能够运行:

```python
nums = [1, 1, 4, 5, 1, 4]

for num in filter(lambda x: x % 2 == 0, nums):
	print(num)
```

## 返回可迭代对象的函数:

- `list(iter)`: 返回一个 `list` 包含 `iter` 中的所有元素
- `tuple(iter)`: 返回 `turple`
- `sorted(iter)`: 返回排序好的 `list`

```python
list1 = [1, 2, 3, 4, 5]

iter1 = iter(list1)
next(iter1) # 1
list2 = list(iter1) # [2, 3, 4, 5]
next(iter1) # StopException
```

# 2. 生成器

> [[../../Programming/python/python学习笔记#生成式和生成器|生成式和生成器]]

一个生成器就是一种迭代器, 其产生由生成器函数决定的元素

生成器函数使用 `yield` 而非 `return`

```python
def events(x):
    for num in range(1, x):
		if num % 2 == 0:
			yield num

iter1 = events(10)
next(iter1) # 2
```

`yield` 的工作流程:

- 当生成器函数被调用时，其直接返回一个迭代器（没有进入 函数体）
- 当 `next()` 被调用时，其进入函数体，从上一次的终止点（初始就是函数体的第一句），运行到下一次的 `yield` 语句 。 
- 如果找到了 `yield` 语句，那么其在下一句停止（这一次的终 止点，作为下一次的起点），并返回 `yield` 语句中的表达式的值
- 如果找不到 `yield` 语句，则在函数的末端终止，并产生一个 `StopIteration` 的异常。

**为什么需要生成器**:

- 生成器是惰性的, 只有在需要时才生成
- 很多时候不需要一次生成整个序列

```python
def odd():
	ret = 1
	while True
		yield ret
		ret += 2
```

对可迭代对象直接 `yield`

```python
def a_and_b(a, b):
	yield from a
	yield from b
```

递归的 `yield`

```python
def frac(n, acc):
	if n == 0:
		yield acc
	else:
		for x in frac(n - 1, acc * n):
			yield x

frac(3, 1) # 6
```

**数的递归生成器**:

```python
def nodes(t): 
	yield label(t) 
	for c in branches(t): 
		yield from nodes(c) 
		
		
t = tree(20, [tree(12, [tree(9, [tree(7), tree(2)]), tree(3)]), tree(8, [tree(4), tree(4)])])
```

