#软件工程与计算 #程序设计 #概念 

> 老师说有点难
> 2024/3/4 补充: 确实有点难

# 1. 判定Hello World 

**写一个程序, 判断一段C语言代码能否输出Hello World**

容易想到, 可以用system指令的方式判断:

```cpp
#include <iostream>

using namespace std;
int main(){
	FILE *file = fopen();
	string s;
	s.getline(file, 100);
	if(strcmp(s, "Hello World!") == 0){
		return 1;
	}else{
		return 0;
	}
}
```

~~*非要写可以用system指令*~~ (也不行)

但事实上无法写出

Proof：

假设存在，先构造对抗程序：调用函数本身，对于返回值0，输出hello world；对于1，不输出hello world

```cpp
#include <iostream>

int main(int argc, char *argv[]){
	if(G(argv[1], argv[1]) == 0){
		std::cout << "Hello World";
	}else{
		std::cout << "Sorry";
	}
	return 0;
}
```

用G判断这这个程序是否输出hello world，发现无法判断

## 规约

假定现在需要判定某个问题B, 只需要证明如果有一个程序能够判定B, 那么一定可以构造另一个程序, 将其转换为Hello World问题

> 其实一般是将其他问题转化成停机问题

$B \rightarrow Hello World$

即 $\lnot Hello World \rightarrow \lnot B$

### Example: 规约停机问题: 

定义程序P, 任意输入I

- 能停机: G(P, I) == 1
- else: G(P, I) == 0

再定义程序G', 对于任意P和I:

- 创建P', 其再P的基础上将输出语句想要打印的字符记录在A中
- 若当前12个字符不匹配 `Hello World`, 则增加一句 `while(1)`
- 超过12: 加`while(1)

运行 G(P', I), 此时G' 为可以判定Hello World的程序. 

因此停机问题不可计算


# 2. [[../../计算系统基础/1. 计算系统概述#1.2 图灵机|图灵机]]介绍


What is 图灵机 (From 计算系统概述)

![[../../计算系统基础/1. 计算系统概述#1.2 图灵机|1. 计算系统概述]]

## 2.1 图灵机

- 一个有穷字符集 $\Sigma$, 纸带上字符属于该字符集, 一般取 $\{ 0, 1 \}$
- 一个有穷状态集 $Q$, 图灵机的状态属于 $Q$
- 操作$O$, 包括移动和更改当前格的位置
- 元素可以用四元组 $( q_i, a, O, q_j )$

除自身外的信息:

- 初始状态 $q_s$ 和停机状态 $q_h$ 
	- 除正常停机外, 若当前状态没有任何对应的指令, 也停机
- 输入: 用 $(n + 1)$ 个 `1` 来表示自然数 $n$, 用 `0` 隔开不同自然数

一个自然数上的函数是可计算的当且仅当存在一个计算他的图灵机

## 2.2 图灵机编码

可以将图灵机指令用图灵机字符表示:

- 用2表示`L`, 3表示`R`
- 用编码数字相同的规则编码指令: (q, a, a', q')
- 每条指令间用 `00` 隔开
- 图灵机可表示为 $\# \Delta_1 00 \# \Delta_2 00 ...$

**可以被图灵机计算的问题称为可计算问题**


## 2.3 通用图灵机

存在一个通用图灵机U, 输入为一个图灵机 $M_1$ 的编码和输入 $I$ , 则其输出和原本图灵机 $M_1$ 的输出一致

**证明其的存在**

Proof by construction: 用构造的方法证明

### Step 1: 构造三个工具图灵机

需要构造三个工具图灵机:

- 拷贝机
- 匹配机
- 替换机

引入 `$` 和 `#`

**拷贝机:** 

构造图灵机, 将 `#` 后的内容拷贝到 `$` 处

How: 引入 `B`, `#` 后拷贝过的内容替换为 `B`

**匹配机:**

匹配 `#` 后和 `$` 后的内容

引入 `B`, 逐个匹配 `$` 和 `#` 后的 `1` 的个数, 按照减法其原理, 但将 `1` 替换为 `B` (方便重复利用)

如果不相等, 回头把所有 `B` 再换成 `1`

**替换机:**

将 `#` 后的内容替换为 `$` 后的内容

- 收缩: 将 `#` 后的内容收缩掉一串 `1`
- 插值: 将 `$` 后的内容逐个插入到 `#` 后 
	- How: `#` 后整体右移一位


### Step 2: 图灵机之间的调用

- 先后调用: 将 $M_1$ 的停机状态设定为 $M_2$ 的起始状态
- 根据内容调用: 额外设定状态, 调用函数思想 

### 算法

三个区域: `$` Buffer, `#` Machine turing number, `@` data tape

1. 把当前状态 $q_i$ 和 `@` 后内容 $a_0$ 拷贝到 Buffer 区
2. 从指令集匹配 $q_i$ 和 $a_0$, 匹配到 $\# \Delta_i$ 
3. 进行 $\# \Delta_i$ 中的操作, 如果是移动, 将 `@` 标识符做相应移动; 如果是改变值, 将 `@` 后内容更改为相应值 (即用 `@` 记录指针的位置)
4. 将 $\# \Delta_i$ 中的状态拷贝到 `$` 区
5. 继续重复

即冯 - 诺伊曼结构


# 3. 停机问题的严格证明

设 $A$ 为自然数集 $N$ 的子集, $A$ 可判定, 即 $A$ 的特征函数 $x_A$ 是图灵可计算的

定义如下两个集合:

$K = \{ \# M: M对于输入 \# M停机\}$

$K_0 = \{ <\# M , x>: 图灵机M对于输入x停机\}$

\*哥德尔编码: $<\# M, x > = 2^{\# M} 3^x$

$\# M$: $M$ 的编码

**证明自停机问题:**

> 康托尔对角线

假设存在图灵机 $H_k$ 可以计算 $x_k$

则 $H_k$ 可以计算出 "对角线" 的值 (即能否停机)

![[../../00 Resource/res/Pasted image 20240304112443.png]]

构造程序 $M_{diag}$ , 其停机与否与对角线结果相反, 可知 $M_{diag}$ 也属于对角线, 则 $M_{diag} (\# M_{diag})$ 无法计算其为 0 还是 1, 即 $H_k$ 无法判断 $M_{diag}$ 是否可停机. 矛盾. 

**证明停机问题: 规约**

将停机问题转换为自停机问题

设 $x_{k_0}$ 为 $K_0$ 的特征函数. 假设存在 $H_{k_0}$ 可以计算 $x_{k_0}$ , 则有 $x_{k_0} <\# M, \# M>$ 可以被计算, 即 $H_{k_0}$ 可以计算 $M$ 的自停机问题, 而前面已经证明了自停机问题是不可计算的, 因此停机问题不可计算.  

**[[../Homework/Homework-A1|Homework: 证明全停机问题:]]**

全停机问题: $\hat{K} = \{M:对于任意输入x都停机 \}$ 是否能求解? 

Proof: 

设 $x_{\hat K}$ 为 $\hat K$ 的特征函数. 假设存在 $H_{\hat K}$ 可以计算 $x_{\hat K}$ 

由于 $\forall M \in K, \forall x \in N, M(x)$ 均会停机, 因此有 $x_{\hat K}(\#M)$ 可被 $H_{\hat K}$ 计算

而 $x_{\hat K}(\#M) = x_K(\#M)$, 由于 $x_K(\#M)$ 不可图灵计算, 因此假设不成立, $H_{\hat K}$ 不存在. 

# 4. m-规约

称集合 $A$ 可以归约到集合 $B$ ( $A \leq_m B$ or $A \rightarrow_m B$), 当且仅当存在一个全函数 $g: N \rightarrow N$, 满足: 

对于任意 $x$ , $x \in A$ 当且仅当 $g(x) \in B$ 

Example: 对于集合 $K$ 和 $K_0$ , 可见 $K \leq_m K_0$


# 5. 判定问题

**指标集:** 在任何输入下输出都相同的两个程序的编码属于的同一个集合

**莱斯定理**: 对于指标集 $A$ , $A \notin \emptyset$ , $A \neq N$ , 那么 $A$ 不可判定


Proof: 将自停机问题规约到 $A$ 上

设 $x_1 \in A$, 空函数 $\uparrow \notin A$ , 对任意 $x$, 构造图灵机 $M_x^e$ 先运行 $M_x(x)$, 而后舍弃其结果, 然后再串联一个编码为 $x_1$ 的图灵机 $M_{x_1}$ , 运行 $M_{x_1}$

将问题转化为了自停机问题

设 $x_2 \notin A$, 如上构造, 则将问题也转化为了自停机问题

