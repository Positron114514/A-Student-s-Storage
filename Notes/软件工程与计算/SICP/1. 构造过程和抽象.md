#è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®— #ç¨‹åºè®¾è®¡ #Scheme #SICP

# ä¸€. æ„é€ è¿‡ç¨‹å’ŒæŠ½è±¡

LispğŸ˜“

Schemeæ–¹è¨€

[é…ç½®Schemeç¯å¢ƒ](https://www.cnblogs.com/unixart/p/9182847.html)

## 1.1 ç¨‹åºè®¾è®¡çš„åŸºæœ¬å…ƒç´ 

### 1.1.1 è¡¨è¾¾å¼

å‰ç¼€è¡¨ç¤º

```scheme
(+ 137 349 114514)
; output: 115000
(* 5 99)
; output: 495
```

Lispé‡‡ç”¨**å‰ç¼€è¡¨ç¤º**, å³å°†è¿ç®—ç¬¦æ”¾åœ¨æ‰€æœ‰è¿ç®—å¯¹è±¡å·¦è¾¹

è¿™ç§è¡¨ç¤ºæ–¹æ³•é€‚åˆå¤šä¸ªå¯¹è±¡, å¹¶ä¸”å¯ä»¥ç›´æ¥æ‰©å……

```scheme
(+ (* 3 5) (- 10 6))
; output: 19
```

- ç¾è§‚æ€§: å°†å±äºç›¸åŒè¿ç®—ç¬¦çš„å„ä¸ªå¯¹è±¡æ”¾åœ¨ä¸€åˆ—:

```scheme
(+ (- 10

Â  Â  Â  Â  (* 114

Â  Â  Â  Â  Â  Â  (/ 2 514)

Â  Â  Â  Â  Â  Â  2334

Â  Â  Â  Â  Â  Â  (+ 114

Â  Â  Â  Â  Â  Â  Â  Â  514))))
```


### 1.1.2 å‘½å&& ç¯å¢ƒ

Schemeä¸­é€šè¿‡`define`æ¥ç»™å˜é‡å‘½å:

```scheme
(define size 3)

(* 5 size)
```


### 1.1.3 ç»„åˆå¼çš„æ±‚å€¼

What to do:
1. æ±‚å€¼è¯¥ç»„åˆå¼çš„å„ä¸ªå­è¡¨è¾¾å¼
2. å°†è¿ç®—ç¬¦ä½œç”¨äºå…¶ä»–å€¼

è¿‡ç¨‹æœ¬èº«æ˜¯é€’å½’çš„

ç”¨æ•°å½¢è±¡çš„è¡¨ç¤ºæ±‚å€¼çš„è¿‡ç¨‹, æ±‚èŒçš„è¿‡ç¨‹ (å€¼å‘ä¸Šç©¿è¡Œ) ä¸ºæ ‘å½¢ç§¯ç´¯çš„ä¸€ä¸ªç‰¹ä¾‹

- æ•°çš„å€¼ä¸ºä»–ä»¬æ‰€è¡¨ç¤ºçš„æ•°å€¼
- å†…éƒ¨è¿ç®—ç¬¦çš„å€¼å³ä¸ºå¯¹åº”çš„æœºå™¨æŒ‡ä»¤
- åç§°çš„å€¼ä¸ºå¯¹åº”çš„å€¼


### 1.1.4 å¤åˆè¿‡ç¨‹

ç¼–ç¨‹è¯­è¨€é€šæ€§:

- æ•° && ç®—æ•°è¿ç®—
- ç»„åˆå¼çš„åµŒå¥—
- å®šä¹‰å˜é‡

**è¿‡ç¨‹å®šä¹‰**: å³å®šä¹‰å‡½æ•°

Example:

```scheme
(define (square x) (* x x))
```

Common type:

```scheme
(define (<name> <paramenters>) <body>)
```


### 1.1.5 è¿‡ç¨‹åº”ç”¨çš„ä»£æ¢æ¨¡å‹

åˆ†ä¸ºåº”ç”¨åºä»£æ¢å’Œæ­£åˆ™åºä»£æ¢

- åº”ç”¨åºä»£æ¢: å…ˆè®¡ç®—æ¯ä¸ªéƒ¨åˆ†å†å¸¦è¿›å»
- æ­£åˆ™åºä»£æ¢: å…ˆæŠŠè¡¨è¾¾å¼å¸¦è¿›å»å†é€’å½’æ±‚å€¼


### 1.1.6 æ¡ä»¶è¡¨è¾¾å¼å’Œè°“è¯

#### æ¡ä»¶è¡¨è¾¾å¼

Lispä¸­, ç”¨`cond`è¡¨ç¤ºæ¡ä»¶: 

```scheme
(define (abs x)
Â  Â  (cond Â  ((> x 0) x)
Â  Â  Â  Â  Â  Â  ((= x 0) x)
Â  Â  Â  Â  Â  Â  ((< x 0) (- x))))
Â  Â  Â  Â  Â  Â  
(write (abs -100))
```

åŸç†: ä»ä¸Šè‡³ä¸‹æ£€æŸ¥è¡¨è¾¾å¼çš„å€¼æ˜¯å¦ä¸ºçœŸ, è‹¥ä¸ºçœŸåˆ™è¿”å›

å¯ä»¥ä½¿ç”¨`else`æ¥ç®€åŒ–:

```scheme
(define (abs x)
Â  Â  (cond Â  ((< x 0) (- x))
Â  Â  Â  Â  Â  Â  (else x)))
Â  Â  Â  Â  Â  Â  
(write (abs -100))
```

è‹¥åªæœ‰ä¸¤ç§æƒ…å†µ, åˆ™å¯ä»¥ä½¿ç”¨`if`

```scheme
(define (abs x)
  (if (< x 0) (- x)
			  x))
```


#### è°“è¯

`and`, `or`, `not`

```scheme
; ä»å·¦åˆ°å³åˆ†åˆ«æ±‚å€¼, å¦‚æœæœ‰å€¼ä¸ºFçš„, åˆ™ç›´æ¥è¿”å›F; å¦‚æœç›´åˆ°ç»“æŸè¿˜æ²¡æœ‰è¿”å›, åˆ™è¿”å›T
(and <e1> ... <en>)
; ä»å·¦åˆ°å³åˆ†åˆ«æ±‚å€¼, å¦‚æœæœ‰å€¼ä¸ºTçš„, åˆ™ç›´æ¥è¿”å›T; å¦‚æœç›´åˆ°ç»“æŸè¿˜æ²¡æœ‰è¿”å›, åˆ™è¿”å›F
(or <e1> ... <en>)
; è¿”å› $\lnot e$
(not <e>)
```


### 1.1.7 ç”¨ç‰›é¡¿æ³•æ±‚å¹³æ–¹æ ¹

> å°±æ˜¯ç‰›é¡¿è¿­ä»£æ³•

**å‡½æ•°å®šä¹‰éœ€è¦å‡ºç°åœ¨å‡½æ•°å¼•ç”¨å‰, æœ‹å‹**

```scheme
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good_enough guess x)
  (< (abs (- (square guess ) x)) 0.001))

(define (sqrt x)
  sqrt_iter(x x))

(define (abs x)
  (if (< x 0) (- x)
			  x))

(define (sqrt_iter guess x)
  (if (good_enough guess x)
	  guess
	  (sqrt_iter (improve guess x) ; é€’å½’, æˆ‘çš„æœ‹å‹, ç”¨é€’å½’å®ç°å¾ªç¯
				  x)))

(define (square x) (* x x))
```


### 1.1.8 è¿‡ç¨‹ä½œä¸ºé»‘ç®±æŠ½è±¡

#### å±€éƒ¨å

å³å±€éƒ¨å˜é‡

#### å†…éƒ¨å®šä¹‰å’Œå—ç»“æ„

åœ¨æŸä¸€è¿‡ç¨‹ä¸­å®šä¹‰ä¸€äº›è¯¥è¿‡ç¨‹ç”¨åˆ°çš„å‡½æ•°, é˜²æ­¢å‘½åå†²çª (Namespaceæ€æƒ³)

```scheme
(define (sqrt x)
  (define (improve guess x)
    (average guess (/ x guess)))

  (define (good_enough guess x)
    (< (abs (- (square guess ) x)) 0.001))
    
  (define (sqrt_iter guess x)
    (if (good_enough guess x)
	    guess
	    (sqrt_iter (improve guess x) ; é€’å½’, æˆ‘çš„æœ‹å‹, ç”¨é€’å½’å®ç°å¾ªç¯
				  x)))
  
  sqrt_iter(x x))
```

å¦‚æœè¿™æ ·å†™, å°±æ²¡å¿…è¦å°†å˜é‡ä»¥å‚æ•°æ–¹å¼å†å‡½æ•°é—´ä¼ é€’äº† (ä½œç”¨åŸŸ)

```scheme
(define (abs x)
Â  (if (< x 0) (- x)
Â  Â  Â  Â  x))

(define (average x y)
Â  (/ (+ x y) 2))

(define (square x) (* x x))
  
(define (sqrt x)
Â  (define (improve guess)
Â  Â  (average guess (/ x guess)))

Â  (define (good_enough guess)
Â  Â  (< (abs (- (square guess ) x)) 0.001))

Â  (define (sqrt_iter guess x)
Â  Â  (if (good_enough guess)
Â  Â  Â  guess
Â  Â  Â  (sqrt_iter (improve guess)
Â  Â  Â  Â  Â  x)))
Â  (sqrt_iter 1.0 x))


(write (sqrt 114514))
```


## 1.2 è¿‡ç¨‹åŠå…¶äº§ç”Ÿçš„è®¡ç®—


### 1.2.1 çº¿æ€§çš„é€’å½’å’Œè¿­ä»£

ä»¥è®¡ç®—é˜¶ä¹˜ä¸ºä¾‹:

```scheme
(define (fractorial x)
  (define (frac_iter n)
	  if(= n 1)  1
				 (* n (frac_iter (- n 1))))
  (frac_iter x))
```

è¯¥è®¡ç®—è¿‡ç¨‹æ„é€ èµ·ä¸€ä¸ªæ¨è¿Ÿæ‰§è¡Œçš„æ“ä½œæ‰€å½¢æˆçš„é“¾æ¡, æ”¶ç¼©é˜¶æ®µè¡¨ç¤ºä¸ºè¿™äº›è¿ç®—çš„å®é™…æ‰§è¡Œ, ç§°ä¸º**é€’å½’è®¡ç®—è¿‡ç¨‹**, è§£é‡Šå™¨éœ€è¦ç»´æŠ¤å°†è¦æ‰§è¡Œçš„æ“ä½œ. é“¾æ¡é•¿åº¦éš`n`çš„å¢å¤§çº¿æ€§å¢å¤§, ç§°ä¸º**çº¿æ€§é€’å½’è¿‡ç¨‹**

å¦ä¸€ç§æ–¹æ³•å¦‚ä¸‹:

```scheme
(define (fractorial n)
  (define (frac_iter num counter max_count)
  (if(> counter max_count) num
						 (frac_iter (* counter num) 
									(+ counter 1)
									max_count)))
  (frac_iter 1 1 n))
```

è¢«ç§°ä¸ºè¿­ä»£ (çº¿æ€§è¿­ä»£)

**å°¾é€’å½’**: èƒ½åœ¨å¸¸é‡è¿‡ç¨‹ä¸­å®ç°è¿­ä»£è®¡ç®—è¿‡ç¨‹, å³ä½¿è¯­æ³•çœ‹èµ·æ¥æ˜¯é€’å½’çš„ (Schemeç‰¹æ€§)


### 1.2.2 [[../../Algorithm/æ•°æ®ç»“æ„åˆé›†/æ ‘|æ ‘]]å½¢é€’å½’

Example: æ±‚è§£æ–æ³¢é‚£å¥‘çš„ä¸€ç§å¾ˆç³Ÿç³•çš„æ–¹æ³•:

```Scheme
(define (fib n)
  (cond ((= n 0) 0)
		((= n 1) 1)
		(else (+ (fib (- n 1))
		          (fib (- n 2))))))
```

æ ‘å½¢é€’å½’æ‰€éœ€çš„æ­¥éª¤æ•°æ­£æ¯”äºèŠ‚ç‚¹æ•°, æ‰€éœ€çš„ç©ºé—´æ•°æ­£æ¯”äºæ ‘çš„æœ€å¤§æ·±åº¦

#### Example: è®¡ç®—é’±èƒ½è¢«åˆ†è§£æˆå‡ ä¸ªéƒ¨åˆ†

C++å®ç°: 

> çªç„¶å‘ç°æˆ‘ä¸å¤ªä¼šç”¨C++æ€è€ƒç¨‹åºäº†, å¾—å¤å»ºäº†

```c++
#include <iostream>

using namespace std;

namespace mf {

int default_type = 6;

int money_types[7] = {1, 2, 5, 10, 20, 50, 100};

int count_amount(int money, int type_current) {
    if (money == 0)
        return 1;
    if (money < 0 || type_current < 0)
        return 0;
    else {
        return count_amount(money, type_current - 1) +
               count_amount(money - money_types[type_current], type_current);
    }
}

}  // namespace mf

int main() {
    int a;
    cout << "Enter the money: " << endl;
    cin >> a;
    cout << mf::count_amount(a, mf::default_type);
    return 0;
}
```

ç»ƒä¹ : è®¡ç®— `sin`

```cpp
double sin(double x) {
Â  Â  if (x < 0.1) {
Â  Â  Â  Â  return x;
Â  Â  } else {
Â  Â  Â  Â  return 3 * sin(x / 3.0) - 4 * std::pow(sin(x / 3), 3);
Â  Â  }
}
```

```scheme
(define (sin x)
Â  (if (< x 0.1)
Â  Â  Â  x
Â  Â  Â  (- (* 3 (sin (/ x 3.0))) (* 4 (cube (sin (/ x 3)))))))
```


### 1.2.3 é€’å½’å’Œè¿­ä»£çš„ä¸€äº›å®ä¾‹

åˆ¤æ–­ç´ æ•°: è´¹é©¬å°å®šç†ï¼šè‹¥ `n`  ä¸ºç´ æ•°ï¼Œåˆ™ $a^n$ ä¸ a mod n åŒä½™.

å› æ­¤å¯ä»¥éšæœºå–å‡ ä¸ªå°äº `n` çš„æ•°åˆ¤æ–­ï¼Œç§°ä¸ºæ¦‚ç‡æ£€æµ‹

```cpp
namespace mf{

int square(int a){
	return a * a;
}

int expmod(int base, int exp, int m){
	if(exp == 0) return 1;
	if(exp % 2){
		return (expmod(base, exp - 1, m) * base) % m;
	}else{
		return square(expmod(base, exp / 2, m)) % m;
	}
}

int is_prime_fm(int target, int times = 3){
	srand(time(0));
	for(int i = 0; i < times; i++){
		int randInt = rand() % target + 1;
		if(expmod(randInt, target, target) != randInt % target){
			return false;
		}
	}
	return true;
}

}
```

Miller_Rabin æ£€æŸ¥ï¼šå¯ä»¥æ¶ˆé™¤æ¦‚ç‡è¯¯å·®

$a^{n - 1} \mod n = 1 \mod n$ 

å¦‚æœåœ¨æ‰§è¡Œ `expmod` è¿‡ç¨‹ä¸­çš„æ•° `x` æ»¡è¶³ï¼š$x^2 \mod n = 1, x \neq 1, x \neq n - 1$ 

```cpp
namespace mf{
	int mr_expmod(int base, int exp, int m){
		if(exp == 0) return 1;
		if(exp % 2){
			return (expmod(base, exp - 1, m) * base) % m;
		}else{
			return square(expmod(base, exp / 2, m)) % m;
		}
	}

	int is_prime_mr(int target, int times = 3){
		srand(time(0));
		for(int i = 0; i < times; i++){
			int randInt = rand() % target + 1;
			int mod = mr_expmod(randInt, target - 1, target);
			if(mod != 1 || mod == -1){
				return false;
			}
		}
		return true;
	}
}
```


## 1.3 ç”¨é«˜é˜¶å‡½æ•°åšæŠ½è±¡

å‡½æ•°å¥—å‡½æ•° (Cè¯­è¨€ä¸­çš„å‡½æ•°æŒ‡é’ˆé‚£ä¸ªæ„æ€)
### 1.3.1 è¿‡ç¨‹ä½œä¸ºå‚æ•°

è€ƒè™‘è¿‡ç¨‹ `sum`, ä»–èƒ½å¤Ÿæ ¹æ®è¾“å…¥çš„å‡½æ•°æ¥å¯¹è¡¨è¾¾æ±‚å’Œ:

```Scheme
(define (sum term a next b)
  (if (> a b)
    0
    (+ (term a)
	   (sum term (next a) next b))))

(define (next_int x) (+ x 1))

(define (cube x) (* x x x))

(display (sum cube 1 next_int 10))

; Output: 3025
```

å¯ä»¥å°†è¿™ä¸ªè¿‡ç¨‹è½¬æ¢ä¸ºè¿­ä»£:

```scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
	    result
		(iter (next a) (+ (term a) result))))
  (iter a 0))
```

åŒæ ·çš„, å¯ä»¥å®šä¹‰è¿‡ç¨‹ `product`

```scheme
(define (product term a next b)
  (define (iter a result)
  (if (> a b)
	  result
	  (iter (next a) (* (term a) result))))
(iter a 1))
```

è¿›ä¸€æ­¥, å¯ä»¥æŠ½è±¡æ›´é«˜é˜¶è¿‡ç¨‹ `accumulate`:

```scheme
(define (accumulate how_to_accumulate function start next_one end)
  (define (iter a result)
    (cond ((< a end) (iter (next_one a) (how_to_accumulate (function a) result)))
          ((= a end) (how_to_accumulate (function a) result))
          (else result)))
  (iter (next_one start) start))
```

å¯ä»¥ä½¿ç”¨ `accumulate` è¿‡ç¨‹å®šä¹‰ `sum` å’Œ `product`

```scheme
(define (sum term a next b)
  (accumulate + term a next b))

(define (product term a next b)
  (accumulate * term a next b))

(define (next_int x) (+ x 1))

(define (cube x) (* x x x))

(display (product cube 1 next_int 5))

(exit)
```

### 1.3.2 ç”¨ lambda æ„é€ è¿‡ç¨‹

```scheme
(display (product cube 1 (lambda (x) (+ x 1)) 5))
```

ç”¨ `let` åˆ›å»ºå±€éƒ¨å˜é‡

```scheme
(let ((a 100)
     (b 101))
  (a + b))
```

æ ¼å¼:

```scheme
(let ((<var1> <exp1>)
	  (<var2> <exp2>)
	  ...
	  (<varn> <expn>))
  <body>)
```

ç”¨ `let` åˆ›å»ºçš„å˜é‡æ‹¥æœ‰å±€éƒ¨ä½œç”¨åŸŸ


æ±‚è§£è¿åˆ†å¼:

```scheme
(define (cont_frac n d k)
  (define (do_iter result i)
    (if (= i 0)
        result
        (do_iter (/ (n i) (+ result (d i))) (+ i 1))))
  (do_iter (/ (n k) (d k)) k))
```

è·å– `e` çš„å€¼

```scheme
(define (get_e)
  (define (func x)
    (if (= (remainder (+ x 1) 3) 0)
        (* 2 (/ (+ x 1) 3))
        1))
  (+ (cont_frac (lambda (x) 1.0) func 100) 2))
```

In Python:

```python
def cont_frac(func_1, func_2, times):  
    result = func_1(times)  
    for i in range(times - 1, 0, -1):  
        result = func_1(i) / (func_2(i) + result)  
    return result  
  
  
def get_e():  
    def func_1(x):  
        return 1  
  
    def func_2(x):  
        if x % 3 == 2:  
            return 2 * (x + 1) // 3  
        return 1  
  
    return cont_frac(func_1, func_2, 100) + 2
```


### 1.3.4 è¿‡ç¨‹ä½œä¸ºè¿”å›å€¼

**æ±‚å¯¼æ•°**:

```python
def deriv(func):  
    dx = 0.000001  
  
    def ret_func(x):  
        return (func(x + dx) - func(x)) / dx  
  
    return ret_func
```

æœ‰äº†æ±‚å¯¼å‡½æ•°å, ç‰›é¡¿è¿­ä»£æ³•å¯ä»¥å¦‚ä¸‹å®ç°:

```python
def newton_iter(func):  
    result = 1.0  
    while True:  
        next = result - func(result) / deriv(func)(result)  
        if abs(next - result) < 0.000001:  
            return next  
        result = next  
  
  
def cbrt(x):  
    return newton_iter(lambda num: num ** 3 - x)
```

#### æŠ½è±¡å’Œç¬¬ä¸€çº§è¿‡ç¨‹

ç‰›é¡¿è¿­ä»£æ³•å’Œä¸åŠ¨ç‚¹æ±‚è§£éƒ½å¯ä»¥å†æŠ½è±¡æˆæ›´ä¸€èˆ¬çš„å½¢å¼:

```python
def fix_point(func, guess):  
    while True:  
        next = func(guess)  
        if abs(next - guess) < 0.000001:  
            return next  
        guess = next  
  
  
def get_fixpoint(func, how_to_transform, guess):  
    return fix_point(how_to_transform(func), guess)  
  
  
def deriv(func):  
    dx = 0.000001  
  
    def ret_func(x):  
        return (func(x + dx) - func(x)) / dx  
  
    return ret_func  
  
  
def newton_trans(func):  
    def ret(x):  
        return x - func(x) / deriv(func)(x)  
  
    return ret  
  
  
def newton_iter(func):  
    return get_fixpoint(func, newton_trans(func), 1.0)
```

æ­¤æ—¶å…¶å®å¯ä»¥èˆå¼ƒç‰›é¡¿è¿­ä»£æ³•, å› ä¸ºç‰›é¡¿è¿­ä»£æ³•ä¹Ÿæ˜¯ `get_fixpoint` çš„ä¸€ä¸ªå…·ä½“å®ä¾‹

ä¾‹å¦‚, ä¸ä½¿ç”¨ `newton_iter` è¿‡ç¨‹, `cbrt` ä¹Ÿå¯ä»¥æŠ½è±¡ä¸ºä»¥ä¸‹è¿‡ç¨‹:

```python
def cbrt(x):  
    return get_fixpoint((lambda num: num ** 3 - x), newton_trans, 1.0)

def cbrt(x):  
    return get_fixpoint((lambda num: x / (num ** 2)), average_damp, 1.0)

def average_damp(func):  
    def ret(x):  
        return (func(x) + x) / 2  
  
    return ret
```

> å¹³å‡é˜»å°¼æ³•: æ±‚ $y = x^3$  çš„è§£, å³æ±‚ $f(x) = \frac{y}{x^2}$ çš„ä¸åŠ¨ç‚¹, å³ $x = \frac{y}{x^2}$ , å³æ±‚å¹³å‡é˜»å°¼ä¸å˜çš„ä½ç½®



# hello.py

```python
def fix_point(func, guess):  
    while True:  
        next = func(guess)  
        if abs(next - guess) < 0.000001:  
            return next  
        guess = next  
  
  
def get_fixpoint(func, how_to_transform, guess):  
    return fix_point(how_to_transform(func), guess)  
  
  
def deriv(func):  
    dx = 0.000001  
  
    def ret_func(x):  
        return (func(x + dx) - func(x)) / dx  
  
    return ret_func  
  
  
def newton_trans(func):  
    def ret(x):  
        return x - func(x) / deriv(func)(x)  
  
    return ret  
  
  
def newton_iter(func):  
    return get_fixpoint(func, newton_trans(func), 1.0)  
  
  
def cbrt(x):  
    return get_fixpoint((lambda num: x / (num ** 2)), average_damp, 1.0)  
  
  
def average_damp(func):  
    def ret(x):  
        return (func(x) + x) / 2  
  
    return ret  
  
  
def cont_frac(func_1, func_2, times):  
    result = func_1(times)  
    for i in range(times - 1, 0, -1):  
        result = func_1(i) / (func_2(i) + result)  
    return result  
  
  
def get_e():  
    def func_1(x):  
        return 1  
  
    def func_2(x):  
        if x % 3 == 2:  
            return 2 * (x + 1) // 3  
        return 1  
  
    return cont_frac(func_1, func_2, 100) + 2  
  
  
def main():  
    print(cbrt(100))  
  
  
if __name__ == '__main__':  
    main()
```