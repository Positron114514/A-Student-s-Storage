#软件工程与计算 #SICP #Scheme #程序设计 

> [!Notes]
> SICP第二章
> PS: 因为要复建python所以用python写了
> PS2: 因为要学习Java所以有些是拿Java写的


# 2.1 数据抽象导引

有点OOP思想

### 2.1.1 例子

Vector in python:

```python
import math  
from enum import Enum  
  
  
class Type(Enum):  
    RECT = 1  
    POLAR = 2  
  
  
class Vector(object):  
  
    def __init__(self, arg1, arg2, type = Type.RECT):  
        self.type = type  
        if type == Type.RECT:  
            self._x = arg1  
            self._y = arg2  
            self.set_pol()  
        elif type == Type.POLAR:  
            self._mag = arg1  
            self._ang = arg2  
            self.set_rect()  
  
    def __add__(self, other):  
        return Vector(self._x + other._x, self._y + other)  
  
    def __sub__(self, other):  
        return Vector(self._x - other._x, self._y - other)  
  
    def __mul__(self, number):  
        return Vector(self._x * number, self._y * number)  
  
    def __truediv__(self, number):  
        return Vector(self._x / number, self._y / number)  
  
    def __str__(self):  
        if self.type == Type.RECT:  
            return f"Vector(x = {self._x}, y = {self._y})"  
        return f"Vector(mag = {self._mag}, ang = {self._ang})"  
  
    def __repr__(self):  
        if self.type == Type.RECT:  
            return f"Vector(x = {self._x}, y = {self._y}, type = {self.type})"  
        return f"Vector(mag = {self._mag}, ang = {self._ang}, type = {self.type})"  
  
    def set_pol(self):  
        self._mag = math.sqrt(self._x ** 2 + self._y ** 2)  
        self._ang = math.atan(self._x / self._y)  
  
    def set_rect(self):  
        self._x = self._mag * math.cos(self._ang)  
        self._y = self._mag * math.sin(self._ang)  
  
    def polar_mode(self):  
        self.type = Type.POLAR  
  
    def rect_mode(self):  
        self.type = Type.RECT  
  
    def reset(self, arg1, arg2, type = Type.RECT):  
        self.type = type  
        if type == Type.RECT:  
            self._x = arg1  
            self._y = arg2  
            self.set_pol()  
        elif type == Type.POLAR:  
            self._mag = arg1  
            self._ang = arg2  
            self.set_coo()  
              
    def get_coord(self):  
        if self.type == Type.RECT:  
            return [self._x, self._y]  
        return [self._mag, self._ang]  
  
  
def main():  
    a = Vector(1, 2, Type.RECT)  
    print(a)  
  
  
if __name__ == "__main__":  
    main()
```

### 2.1.2 抽象屏障

数据抽象的基本思想: 为每一类数据对象标识出一组操作, 使得对这类对象的所有操作都可以也只可以用这些操作来表述

抽象屏障即层层包装的每层的包装

把对于具体表示方式的依赖性限制到少数几个界面过程是有益的


### 2.1.3 数据是什么

一组适当的选择函数和构造函数

# 2.2 层次的数据和闭包性质

## 2.2.1 序列的表示

这节好像在讲数组 ()

查钱的分解种数 (Java 版)

```java
class Count_change{  
    public static enum Coins_type{UK, US, CN};    
  
    public static int get_change_type(Coins_type type, int total_money){  
	    int[] CN_coins = {1, 5, 10, 20, 50, 100};  
	    int[] UK_coins = {1, 2, 5, 10, 20, 50, 100};  
	    int[] US_coins = {1, 5, 10, 25, 50};
        switch(type){  
            case UK:  
                return Count_change.count_change(total_money, UK_coins.length - 1, UK_coins);  
            case US:  
                return Count_change.count_change(total_money, US_coins.length - 1, US_coins);  
            case CN:  
                return Count_change.count_change(total_money, CN_coins.length - 1, CN_coins);  
            default:  
                System.out.println("Invalid coins type. Set to CN_Coins.");  
                return Count_change.count_change(total_money, CN_coins.length - 1, CN_coins);  
        }  
    }  
  
  
    public static int count_change(int money_left, int type_current, int[] coin_type){  
        if(money_left < 0){  
            return 0;  
        }  
        if(money_left == 0){  
            return 1;  
        }else{  
            return count_change(money_left - coin_type[type_current], type_current, coin_type) + count_change(money_left, type_current - 1, coin_type);  
        }  
    }  
}
```

Lisp对数组 (表) 的实现: 用序对, 每个序对的第一个元素为此处的值, 第二个元素指向下一个序对

`car` 返回序对的第一个值, `cdr` 返回序对的第二个值


## 2.2.2 层次性结构

[[../../Algorithm/数据结构合集/树|树]]

```scheme
(cons (list 1 2) (list 3 4))
```

![[../../Excalidraw/SICP-Tree|SICP-Tree]]

递归是一种处理树的很自然的方式

计算树的叶子数 (用类似 Scheme 中的序对的方式来表示数)

```python
def count_leaves(target_list):  
    if type(target_list) is not list:  
        return 1  
    if len(target_list) == 0:  
        return 0  
    else:  
	    # opereations you want
        return count_leaves(target_list[0]) + count_leaves(target_list[1])


def main():  
    list1 = [[1, []], [[1, []], [2, [1, []]]]]  
    print(count_leaves(list1))
```

**对树的映射**

W1: 和 `count_leaves` 相同的方法

```python
def tree_operate(target_list, func):  
    if type(target_list) is not list:  
        return func(target_list)  
    if len(target_list) == 0:  
        return []  
    else:  
        return [tree_operate(target_list[0], func), tree_operate(target_list[1], func)]  

def main():  
    list1 = [[1, []], [[1, []], [2, [1, []]]]]  
    print(tree_operate(list1, (lambda x: x**2)))
```

W2: 使用 `map` 过程操作树

```python
def scale_tree(tree, factor):
    if isinstance(tree, list):
        return list(map(lambda subtree: scale_tree(subtree, factor), tree))
    else:
        return tree * factor

tree = [[1, 2], [3, [4, 5]]]
scaled_tree = scale_tree(tree, 2)
print(scaled_tree)
```

> 所以所有 lisp 过程本质上都是lambda表达式? 那 lisp 的数据是否是[[../Notes on Class/3. Lambda演算#3.3 基于lambda演算的编程|用lambda演算]]实现的?

## 2.2.3 序列作为约定的界面

考虑两个过程: 

1. 返回一棵树中值为奇数的叶子的值的平方和组成的表
2. 返回由斐波那契数列的偶数项组成的表

这两个过程的描述很相似:


- 过程1:
	- 枚举出树叶
	- 过滤, 选择其中的奇数
	- 对选出的每个数求平方
	- 用过程 `+` 累计起结果, 从 0 开始
- 过程2:
	- 枚举出从0到 `n` 的整数
	- 计算每个整数对应的斐波那契数
	- 过滤, 选出其中偶数
	- 用 `cons` 累积结果, 从空表开始

组织程序, ·使信号流明显的表现在写出的过程中, 能极大的提成程序的清晰性和可读性

### 序列操作

关注由一个步骤流向下一个步骤的信号, 将步骤分解:

Example:

```python
# 过滤操作
def my_filter(func, target):  
    return [x for x in target if func(x)]  
  
# 聚集起来  
def my_accumulate(how, init, target):  
    ret = init  
    for x in target:  
        ret = how(ret, x)  
    return ret  
  
# 将符合func的target中的元素放在列表里返回  
def my_map(func, target):  
    return [func(x) for x in target]  
  
# 枚举出树叶  
def enumerate_tree_leaves(tree):  
    if type(tree) is not list:  
        return [tree]  
    elif not tree:  
        return []  
    else:  
        return enumerate_tree_leaves(tree[0]) + enumerate_tree_leaves(tree[1])  
  
# 过滤出奇数  
def odd_filter_operate(num):  
    if num & 1 == 1:  
        return True  
    return False  

# 加法操作 可以用lambda表达式替换
def add_operate(num1, num2):  
    return num1 + num2  
  
# 平方操作  
def square_operate(num1):  
    return num1 * num1  
  
# 将树中为奇数的叶子平方再加和  
def sum_odd_squares(tree):  
	# 枚举出叶子
    leaves = enumerate_tree_leaves(tree)
    # 过滤出奇数的值 
    filtered = my_filter(odd_filter_operate, leaves) 
    # 对过滤结果做操作
    squared = my_map(square_operate, filtered) 
    # 累积起过滤结果 
    return my_accumulate(add_operate, 0, squared)  
  
  
def main():  
    tree1 = [[1, []], [[1, [2, [3, [4, []]]]], [1, [9, []]]]]  
    print(sum_odd_squares(tree1))
```

将程序表示为基于过程的操作, 有助于模块化的程序设计

### 嵌套映射

将通常用嵌套循环表述的计算也使用这种方法操作:

```python
def flat_map(func, target):  
    empty_list = []  
    return my_accumulate(list_append, empty_list, my_map(func, target))  
  
  
def list_append(ret_list, x):  
    if type(x) == list:  
        ret_list.extend(x)  
    else:  
        ret_list.append(x)  
    return ret_list  # Return the modified list  
  
  
def get_prime_pairs(start, end):  
    def get_pairs(num_start):  
        # enumerate  
        num_lists = [x for x in range(start, num_start)]  
        # map  
        pair_lists = my_map((lambda x: [x, num_start]), num_lists)  
        return pair_lists  
    # enumerate  
    num_list = [x for x in range(start, end+1)]  
    # flat_map  
    num_pairs = flat_map(get_pairs, num_list)  
    # filter  
    filtered_pairs = my_filter((lambda x: is_prime(sum(x))), num_pairs)  
    return filtered_pairs
```

### 强健设计的语言层次

分层设计

# 2.3 符号数据

## 2.3.2 符号求导


## 2.3.3 集合

![[../../Programming/Java/Java核心技术笔记-OOP#一个sortedSet类|Java: sortedSet类]]


### 2.3.4 实例: Huffman编码树

左0右1

![[../../00 Resource/res/NodeContent.java]]

![[../../00 Resource/res/HuffmanTree.java]]

应该算是一个小项目了

结构: SortedCharSet -> NodeContent -> Node -> HuffmanTree

我觉得写的比较好的地方:

- **分层清晰**, 类方法比较全
- 用String存储了二进制串
- 使用排序方法对编码ArrayList根据 Weight 进行排序
- 在Node中实现了 merge 方法, 很方便


# 2.4 抽象数据的多重表示

## 2.4.1 复数的表示

可以沿用之前的 [[2. 构造数据抽象#2.1.1 例子|Vector 类 (Python)]] 和 [[../../Programming/C++/C++学习笔记#5.3 实战演练 编写Vector类|Vector 类 (C++)]] , 具体思想也大致相同:

~~那这块是不是得再用Java写一遍了~~

(感觉没啥大用, 等啥时候复建Java的时候想写再写把)

## 2.4.2 带标志数据

**最小允诺原则: 推迟具体实现的决定**

> [!Notes] Tips : 最小允诺原则
> 复数的例子和有理数的例子有很多的相似之处，不过最大的不同，也是这里数据驱动的要点，是我们的低层实现有两种形式，并且可以相互转换。
> 透过这种抽象屏蔽，我们对实际计算方法的选择和实现都可以延后。我们称之为“最小允诺原则”。
> 最小允诺原则（Principle of Least Commitment）指的是编程时应该尽可能地延迟对程序的决策，以便在以后的阶段有更多的灵活性和选择。

具体来说，最小允诺原则鼓励编程者尽可能地推迟做出决定，特别是关于数据结构和算法的选择，直到必要时才进行。这样做的好处是可以使程序更加通用、灵活，减少对特定实现细节的依赖，从而提高代码的可维护性和可扩展性。

最小允诺原则在设计和实现程序时是一个重要的指导原则，可以帮助开发者编写出更加优雅和灵活的代码，更好地应对需求的变化和未来的扩展。

使用带标识的数据有时能够更大的推迟具体实现的决定时间

Example: 在 Vector 类中使用 RECT 和 POLAR 来标识目前数据是哪种类型

重要的组织策略: 数据对象从层次到层次之间的传递为 剥去和加上标志

## 2.4.3 数据导向的程序设计和可加性

给数据标识类型, 能提高程序的**可加性**

数据导向的程序设计: 使程序能根据由过程和类型组成的表格工作的程序设计技术

把整个识别类型和选择过程的过程抽象为一个过程 (查表格)

制作一个 Scheme 程序包, 防止命名冲突

```Scheme
(define (make-package)
  (let ((internal-env (make-environment)))
    (lambda (sym)
      (cond ((eq? sym 'export) internal-env)
            ((eq? sym 'define)
             (lambda (name value)
               (define (internal-lookup sym)
                 (let ((env (lookup-in-environment sym internal-env)))
                   (if env (env-lookup sym env) #f)))
               (let ((existing (internal-lookup name)))
                 (if existing
                     (error "Name already defined: " name)
                     (env-define name value internal-env))))
            ((eq? sym 'lookup)
             (lambda (name)
               (let ((binding (lookup-in-environment name internal-env)))
                 (if binding
                     (env-lookup name binding)
                     (error "Name not found: " name)))))
            (else (error "Unknown operation: " sym))))))

(define (define-in-package package name value)
  ((package 'define) name value))

(define (lookup-in-package package name)
  ((package 'lookup) name))

(define (export-from-package package)
  ((package 'export)))

(define (export-symbol package name)
  (let ((internal-env (export-from-package package)))
    (if (lookup-in-environment name internal-env)
        (error "Name already exported: " name)
        (env-define name #t internal-env))))

(define (import-symbol package1 symbol package2)
  (let ((value (lookup-in-package package2 symbol)))
    (define-in-package package1 symbol value)))

;; Example usage:

(define my-package (make-package))

(define-in-package my-package 'x 10)
(define-in-package my-package 'y 20)

(display (lookup-in-package my-package 'x)) ; Output: 10
(newline)

(display (lookup-in-package my-package 'y)) ; Output: 20
(newline)

(export-symbol my-package 'x)
(import-symbol my-package 'y my-package)

(display (lookup-in-package my-package 'x)) ; Output: 10
(newline)

(display (lookup-in-package my-package 'y)) ; Output: 20
(newline)
```

~~GPT写的, 我自己也没看懂啥原理~~

数据导向风格实现求导程序:

```Scheme
(define (derive exp var)
  (cond ((is_number? exp) 0)
	    ((is_variable? exp) (if (same exp var) 1 0))
	    (else (get 'derive (operator exp) (operands exp)
												   var))))

(define (operator exp) (car exp))

(define (operands exp) (cdr exp))
```

**消息传递**

数据导向程序设计中最关键的想法: 通过显示处理**操作- 类型**表格的方式, 管理程序中的各种通用型操作

而2.4.2节中的程序设计风格为**基于类型进行分派**的组织方式, 让每个操作管理自己的分派 (即在数据中包括类型, 从而让操作自动识别类型) , 即将操作-类型表格分为一行一行, 每个操作代表一行

Another Way: 将表格按列分解, 分成不同的对象

Example: In Java 我写的 `sortedIntSet` `sortedCharSet` (虽然但是很sb) `sortedCondSetCI`

以操作的名字作为输入而后在对应类中寻找该操作

```python
def make_from_real_imag(*para):  
    def dispatch(operator):  
        if operator == 'add':  
            ret = [0, 0]  
            for i in para:  
                ret[0] += i[0]  
                ret[1] += i[1]  
            return ret  
        elif operator == 'real_part':  
            return para[0][0]  
        elif operator == 'imag_part':  
            return para[0][1]  
          
    return dispatch
```


# 2.5 带有通用型操作的系统


## 2.5.1 通用性算术运算

即能够自动识别类型并做算术运算的系统

Example: `add` 两个数, 两个向量, 两个复数会产生不同结果. 

C++中可以用[[../../Programming/C++/C++学习笔记#5.1 运算符重载|运算符重载]]来实现

给对象 `attach` 标签然后做操作时检测标签


## 2.5.2 不同类型数据的组合

一种方法是对每个能操作的的不同类型的数据定义一个新函数

但当类型数量增加时, 如果该类型能和现存的其他类型做运算, 那么就很难处理该类型, 需要添加大量的新过程在表里. 很难组织起来

按自己的理解稍微写了一个 (还没完全写完)

```python
# content: key = 'name(type[0], ...)', value = function
funcs = {}  
coercion = {}  
  
  
def put(name, types, func):  
    if type(name) is not str:  
        print('Name must be a string')  
    if not callable(func):  
        print('Function must be a function')  
  
    target_string = name + '('  
    if type(types) is not list:  
        target_string += str(types) + ')'  
    else:  
        for element in types:  
            target_string += str(element) + ', '  
        target_string = target_string[:-2] + ')'  
  
    funcs[target_string] = func  
  
  
def put_coercion(type_origin, type_change_to, func):  
    coercion[type_origin + '->' + type_change_to] = func  
  
  
# could only be used when having two arguments  
# not finished  
def get(name, types):  
    target_string = name + '('  
    if type(types) is not list:  
        print('Name must be a 2-len string')  
        return None  
    elif len(types) is not 2:  
        print('Name must be a 2-len string')  
        return None  
    else:  
        target_string += types[0] + ', ' + types[1] + ')'  
  
    if target_string in funcs:  
        return funcs[target_string]  
    else:  
        if types[0] + '->' + types[1] in coercion:  
            new_arg = coercion[types[0] + '->' + types[1]]  
  
  
def main():  
    put('add', ['int', 'int'], lambda x, y: x + y)  
    put('sub', ['int', 'int'], lambda x, y: x - y)  
    put('mul', ['int', 'int'], lambda x, y: x * y)  
    print(funcs)  
    print(get('add', ['int', 'int'])(2, 3))  
  
  
if __name__ == '__main__':  
    main()
```

### 强制

即强制类型转换, 可以减少重载次数 (即减少编写每个类型的次数)

将强制过程安装在一个特殊的强制表格中, 用类型名做过程名 (索引)

此时在运算前可以检测变量类型, 若类型不匹配则做强制; 如果不存在对应强制, 则返回错误

通过查找图来做一些多个步骤的类型转换

为什么能减小复杂度: 类型转换只依赖于类型本身

### 类型的层次结构

类型之间存在层次

Example: 整数 -> 有理数 -> 实数 -> 复数

任何对于有理数的操作都能用于整数

整数是有理数的子类型, 有理数是整数的超类型

这种每个类型只有至多一个子类和超类的结构称为关系塔

([[../../Programming/Miscell/面向对象编程思想|OOP]]中的继承思想)

A new way: 不做强制, 对每个类型做 `raise` 操作 (提升他的类型) 

塔形结构的优点: 能很方便的 "下降" 一个数据对象

### 层次结构的不足

当非塔形结构时会非常混乱

 