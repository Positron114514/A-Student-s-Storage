# 算法学习笔记

## 一. 动态规划

***调教GPT***   你是一名C语言程序设计教师，现在你的一位学生向你询问什么是 **替换** ，请你为他详细的讲解，并附加多个具体例子以及代码使你的讲解更加易于理解



### 一.动态规划详解

What GPT said：

当一位学生向你询问什么是动态规划算法时，你可以向他详细解释动态规划的概念、基本原理以及应用，以便帮助他理解这一重要的计算机科学和算法概念。

 

#### 1. 什么是动态规划算法？

 

动态规划（Dynamic Programming）是一种解决复杂问题的算法设计技术，常用于优化问题，特别是那些可以被拆分为子问题并具有重叠子问题性质的问题。它的核心思想是将问题分解为一系列重叠子问题，解决每个子问题一次，并将其结果存储起来，以便后续使用，从而减少冗余计算。动态规划通常用于优化问题的求解，例如最大值、最小值、最优路径等。

 

#### 2. 动态规划的基本原理

 

动态规划算法的基本原理可以总结为以下几个关键概念：

 

- **问题分解**：将原始问题分解为一系列相互重叠的子问题。这些子问题通常以递归的方式进行处理。

 

- **状态定义**：确定如何表示子问题的状态，以便存储和重用结果。状态通常用数组、矩阵或字典来表示。



- **状态转移方程**：定义子问题之间的关系，通常是通过一个**递推关系**来表达。这个方程描述了如何从一个子问题的解推导出另一个子问题的解。

 

- **初始条件**：确定基本情况下的子问题的解，通常是问题的边界条件。这些通常是最小规模的子问题，可以直接解决。

 

- **自底向上或自顶向下**：动态规划可以采用自底向上（迭代）或自顶向下（递归）的方式来求解。自底向上通常需要一个循环来处理子问题，而自顶向下通常需要递归函数。

 

#### 3. 动态规划的应用

 

动态规划算法在各种领域和问题中都有广泛的应用。以下是一些示例：

 

-  **最大子序列和问题**：如前面所提到的，动态规划可用于查找数组中具有最大和的连续子序列。

 

- **最短路径问题**：动态规划可用于查找从一个地点到另一个地点的最短路径，如在地理信息系统（GIS）中的导航。

 

-  **背包问题**：动态规划可用于确定如何在背包中放置物品，以使得总价值最大，而不超过背包的容量。

 

- **编辑距离问题**：动态规划可用于确定两个字符串之间的最小编辑操作（插入、删除、替换）次数，例如在拼写检查或字符串比较中。

 

-  **股票交易问题**：动态规划可用于确定在买卖股票市场中获得最大利润的策略。

 

#### 4. 总结

 

动态规划是一种重要的算法设计技术，用于解决各种优化问题。它通过将问题分解为子问题、存储子问题的解并利用重叠子问题性质，来提高问题的求解效率。理解动态规划的基本原理和应用场景将有助于学生更好地应用它来解决实际问题，并提高他们的算法设计能力。



#### 5.实例

##### 最大子序列和问题

```c
int maxSubArray(int nums[], int n) {

  int max_sum = nums[0];

  int current_sum = nums[0];

  

  for (int i = 1; i < n; i++) {

​    current_sum = max(nums[i], current_sum + nums[i]);

​    max_sum = max(max_sum, current_sum);

  }

  

  return max_sum;

}
```

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231101102419447.png" alt="image-20231101102419447" style="zoom: 80%;" />

##### 最长递增子序列问题



**最长递增子序列（LIS）** 是一个常见的计算机科学问题，通常在数组中寻找一组元素，这些元素按升序排列，并且长度尽可能长。换句话说，LIS 是原始数组的一个子序列，其中元素的顺序是递增的，且该子序列的长度最长。

 

LIS 的长度是指子序列中包含的元素数量。这个问题可以在不修改原始数组的前提下找到递增子序列。

 

**举例：**

 

考虑数组 `[10, 22, 9, 33, 21, 50, 41, 60, 80]`。

 

\- 一个递增子序列是 `[10, 22, 33, 50, 60, 80]`，长度为 6。

\- 另一个递增子序列是 `[10, 22, 33, 41, 60, 80]`，同样长度为 6。

\- 最长递增子序列是 `[10, 22, 33, 50, 60, 80]`，长度为 6。

 

**解决问题的方法：**

 

通常，解决最长递增子序列问题的方法是使用动态规划。以下是一个简单的动态规划算法，用于寻找给定数组的最长递增子序列的长度：

 

- 创建一个与原始数组相同长度的数组 `lis`，其中 `lis[i]` 表示以第 `i` 个元素结尾的最长递增子序列的长度。初始时，`lis` 数组中的每个元素都设置为1，因为每个单独的元素本身也构成一个递增子序列。

 

- 遍历原始数组，对于每个元素 `nums[i]`，再遍历在它之前的元素 `nums[j]`（`j` 从 0 到 `i-1`），比较 `nums[i]` 和 `nums[j]`。

 

- 如果 `nums[i]` 大于 `nums[j]`，说明可以将 `nums[i]` 添加到以 `nums[j]` 结尾的递增子序列中，因此更新 `lis[i]` 为 `lis[j] + 1`。

-  继续遍历并重复这个过程，直到遍历完整个数组。

 

- 最后，`lis` 数组中的最大值即为最长递增子序列的长度。

 

动态规划的核心思想是，通过比较每个元素与之前元素的大小关系，构建以每个元素结尾的最长递增子序列的长度，最终找到整个数组中的最长递增子序列的长度。

 

最长递增子序列问题在算法和应用领域都具有重要性，它可以用来解决诸如任务调度、股票交易策略、DNA序列匹配等多种问题。

 

 

```c
#include <stdio.h>

int lengthOfLIS(int nums[], int n) {

  int lis[n];

  int max_length = 1;

    
  for (int i = 0; i < n; i++) {

​    lis[i] = 1;

​    for (int j = 0; j <i; j++) {

​      if (nums[i] > nums[j] && lis[i] < lis[j] + 1) {

​        lis[i] = lis[j] + 1;

​      }

​    }

​    if (lis[i] > max_length) {

​      max_length = lis[i];

​    }

  }

 

  return max_length;

}

 

int main() {

  int nums[] = {10, 22, 9, 33, 21, 50, 41, 60, 80};

  int n = sizeof(nums) / sizeof(nums[0]);

  int result = lengthOfLIS(nums, n);

  printf("Length of Longest Increasing Subsequence: %d\n", result);

  return 0;

}
```







### 二. 背包

背包问题是一个经典的 <u>组合优化</u> 问题，通常在算法和离散数学课程中讨论。它的目标是在给定一组物品和一个限制的容量下，找到一种方式来装入这些物品，使得它们的总价值最大化。背包问题可以分为多个变种，包括0/1背包问题、分数背包问题和多重背包问题。我将逐个解释这些问题，并提供一些代码示例来帮助理解。



#### 1.**0/1 背包问题**：

在0/1背包问题中，每个物品要么放入背包（取 1），要么不放（取 0）。每个物品有一个重量和一个价值，背包有一个容量限制。目标是找到一种放置方式，使得装入背包的物品的总价值最大化，同时不超过背包的容量限制。

```c
#include <stdio.h>

int max(int a, int b) { return (a > b) ? a : b; }

int knapsack_01(int values[], int weights[], int n, int capacity) {
    int dp[n + 1][capacity + 1];
    
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            if (i == 0 || w == 0)
                dp[i][w] = 0;
            else if (weights[i - 1] <= w)
                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
            else
                dp[i][w] = dp[i - 1][w];
        }
    }
    
    return dp[n][capacity];
}
```

这段代码实现了一个经典的动态规划算法，用于解决0/1背包问题。让我详细解释一下这段代码的功能和工作原理。

这段代码定义了一个函数 `knapsack_01`，它接受以下参数：

- `values[]`：一个整数数组，表示每个物品的价值。
- `weights[]`：一个整数数组，表示每个物品的重量。
- `n`：表示可供选择的物品数量。
- `capacity`：表示背包的容量限制。

下面是这段代码的工作原理：

1. 创建一个二维数组 `dp`，其中 `dp[i][w]` 表示在前 `i` 个物品中选择，使得总重量不超过 `w` 时的最大总价值。
2. 使用两个嵌套的循环遍历 `i` 从 0 到 `n`，遍历 `w` 从 0 到 `capacity`，依次考虑前 `i` 个物品和背包容量从 0 到 `capacity` 的情况。
3. 对于每个 `(i, w)` 组合，代码执行以下操作：

   - 如果 `i` 等于 0（表示没有可选的物品）或 `w` 等于 0（表示背包容量为0），则将 `dp[i][w]` 设置为0，因为在这种情况下，无法装入任何物品。
   - 否则，检查当前物品的重量 `weights[i - 1]` 是否小于等于 `w`（`i - 1` 是因为数组索引从0开始）。如果是，就有两种选择：
     - 选择装入当前物品，将当前物品的价值 `values[i - 1]` 加上前一个状态 `dp[i - 1][w - weights[i - 1]]`，表示装入当前物品后的最大总价值。
     - 不选择装入当前物品，直接继承前一个状态 `dp[i - 1][w]`，表示不装入当前物品的最大总价值。
   - 选择上述两种选择中的较大值作为 `dp[i][w]` 的值。
   - 如果否, 则无法装入该物品, 直接继承前一个状态`dp[i - 1][w]`.
4. 最终返回 `dp[n][capacity]`，表示在考虑了所有物品后，背包容量为 `capacity` 时的最大总价值。

这段代码n的关键思想是使用动态规划来构建一个二维表格，逐步填充表格中的值，最终找到最优解。这是一个非常高效的算法，可用于解决0/1背包问题，以确定如何最大化背包中物品的总价值。



#### 2.**分数背包问题**：
在分数背包问题中，每个物品可以被分割成小部分，也就是可以取一个小数值。每个物品有一个重量和一个价值，背包仍然有一个容量限制。目标是找到一种方式，使得装入背包的物品的总价值最大化。

```c
#include <stdio.h>

struct Item {
    int weight;
    int value;
};

int compare(const void *a, const void *b) {
    double ratio1 = ((struct Item *)a)->value / (double)((struct Item *)a)->weight;
    double ratio2 = ((struct Item *)b)->value / (double)((struct Item *)b)->weight;
    return ratio2 > ratio1 ? 1 : -1;
}

double fractionalKnapsack(struct Item items[], int n, int capacity) {
    qsort(items, n, sizeof(struct Item), compare);
    double maxValue = 0.0;
    int currentWeight = 0;
    
    for (int i = 0; i < n; i++) {
        if (currentWeight + items[i].weight <= capacity) {
            currentWeight += items[i].weight;
            maxValue += items[i].value;
        } else {
            double remaining = capacity - currentWeight;
            maxValue += items[i].value * (remaining / items[i].weight);
            break;
        }
    }
    
    return maxValue;
}
```



#### 3.**多重背包问题**：

在多重背包问题中，每个物品有一个给定的数量，可以取 0 到该数量。其他规则与0/1背包问题相似。

多重背包问题的代码相对较长，因此我不会在这里提供完整的示例。你可以参考相关算法书籍或在线教程来查找更详细的示例代码。

这些是背包问题的几种变种，它们在实际生活中有很多应用，如资源分配、货物装载等。希望这些示例代码和解释有助于你理解背包问题的基本概念。如果你有更多问题或需要进一步的解释，请随时提问。

